!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],n):n((e="undefined"!=typeof globalThis?globalThis:e||self)["rt-renderer"]={},e.THREE)}(this,(function(e,n){"use strict";function t(e){if(e&&e.__esModule)return e;var n=Object.create(null);return e&&Object.keys(e).forEach((function(t){if("default"!==t){var a=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(n,t,a.get?a:{enumerable:!0,get:function(){return e[t]}})}})),n.default=e,Object.freeze(n)}var a=t(n);class i extends n.Material{constructor(e){super(),this.materialType="RayTracingMaterial",this.isRayTracingMaterial=!0,this.workflow="Metalness",this.color=new n.Color(16777215),this.roughness=.5,this.metalness=0,this.map=null,this.emissive=new n.Color(0),this.emissiveMap=null,this.normalMap=null,this.normalScale=new n.Vector2(1,1),this.roughnessMap=null,this.metalnessMap=null,this.specularTint=0,this.sheen=0,this.sheenTint=.5,this.clearcoat=0,this.clearcoatRoughness=0,this.subsurface=0,this.alpha=1,this.ior=1.5,this.transmission=0,this.atDistance=1,this.extinction=new n.Color(16777215),this.anisotropic=0,this.specularColor=new n.Color(16777215),this.glossiness=1,this.specularMap=null,this.glossinessMap=null,this.setValues(e)}copy(e){return this.materialType=e.materialType,this.isRayTracingMaterial=e.isRayTracingMaterial,this.color=(new n.Color).copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.emissive=(new n.Color).copy(e.emissive),this.emissiveMap=e.emissiveMap,this.normalMap=e.normalMap,this.normalScale=(new n.Vector2).copy(e.normalScale),this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.specularTint=e.specularTint,this.sheen=e.sheen,this.sheenTint=e.sheenTint,this.clearcoat=e.clearcoat,this.clearcoatRoughness=e.clearcoatRoughness,this.subsurface=e.subsurface,this.transmission=e.transmission,this.ior=e.ior,this.atDistance=e.atDistance,this.anisotropic=e.anisotropic,this.extinction=(new n.Color).copy(e.extinction),this.alpha=e.alpha,this}clone(){return(new this.constructor).copy(this)}fromBasicMaterial(e){const n=new this.constructor;return n.name=e.name,e.color&&n.color.copy(e.color),e.map&&(n.map=e.map),n}fromStandardMaterial(e){const n=new this.constructor;return n.name=e.name,n.color.copy(e.color),n.roughness=e.roughness,n.metalness=e.metalness,n.transmission=e.transmission||0,n.ior=e.ior||1.5,n.clearcoat=e.clearcoat||0,n.clearcoatRoughness=e.clearcoatRoughness||0,n.sheen=e.sheen||0,n.sheenTint=e.sheenTint||.5,n.alpha=e.opacity,n.map=e.map,n.emissive.copy(e.emissive),n.emissiveMap=e.emissiveMap,n.normalMap=e.normalMap,n.normalScale.copy(e.normalScale),n.roughnessMap=e.roughnessMap,n.metalnessMap=e.metalnessMap,e.isGLTFSpecularGlossinessMaterial&&(n.workflow="Specular",n.specularColor.copy(e.specular),n.glossiness=e.glossiness,n.specularMap=e.specularMap,n.glossinessMap=e.glossinessMap),n}}function o(e,t){const a=[],o=[];e.traverse((e=>{e.isMesh?e.geometry?e.material?(e.material.isMeshStandardMaterial?e.material=(new i).fromStandardMaterial(e.material):e.material.isRayTracingMaterial||(e.material=(new i).fromBasicMaterial(e.material)),a.push(e)):console.warn(e,"must have a material property."):console.warn(e,"must have a geometry property."):e.isLight&&o.push(e)}));const s={data:e.environment,intensity:e.envMapIntensity||1},l=s.data&&s.data.isTexture,f=o.length||0;let d=null;return f&&(d=function(e){const n={};return n.position=e.map((e=>e.position)),n.emission=e.map((e=>e.emission)),n.p1=e.map((e=>e.p1)),n.p2=e.map((e=>e.p2)),n.radius=e.map((e=>e.radius)),n.area=e.map((e=>e.area)),n.type=e.map((e=>e.type)),n.visible=e.map((e=>e.visible)),n.position=[].concat(...n.position.map((e=>e.toArray()))),n.emission=[].concat(...n.emission.map((e=>e.toArray()))),n.p1=[].concat(...n.p1.map((e=>e.toArray()))),n.p2=[].concat(...n.p2.map((e=>e.toArray()))),n.params=r({data:n.radius,channels:1},{data:n.area,channels:1},{data:n.type,channels:1},{data:n.visible,channels:1}),n}(o.map((e=>{const t={};switch(t.position=e.position,t.emission=e.color.multiplyScalar(e.intensity),t.radius=e.radius||0,t.area=0,t.visible=Number(e.visible),t.p1=new n.Vector3,t.p2=new n.Vector3,e.type){case"RectAreaLight":if(t.type=0,e.width&&e.height){const a=new n.PlaneGeometry(e.width,e.height),i=new n.Vector3;e.target&&i.copy(e.target);const o=(new n.Vector3).subVectors(e.position,i),r=(new n.Vector3).copy(o).negate();a.lookAt(r);const s=a.attributes.position.array,l=new n.Vector3(s[0],s[1],s[2]).add(e.position),f=new n.Vector3(s[6],s[7],s[8]).add(e.position),d=new n.Vector3(s[9],s[10],s[11]).add(e.position);t.position.copy(f),t.p1=d.sub(f),t.p2=l.sub(f),t.area=(new n.Vector3).crossVectors(t.p1,t.p2).length()}break;case"QuadLight":t.type=1,t.p1=e.v1.sub(e.position),t.p2=e.v2.sub(e.position),t.area=(new n.Vector3).crossVectors(t.p1,t.p2).length();break;case"SphereAreaLight":t.type=2,t.area=4*Math.PI*e.radius**2;break;case"PointLight":t.type=4,t.area=0;break;case"DirectionalLight":t.type=3,e.target&&t.p1.copy(e.target),t.area=0;break;default:console.warn(`Unsupported lighting type: ${e.type}.`)}return t})))),{environment:s,isTextureEnv:l,camera:t,meshes:a,meshLights:d,meshLightsNum:f}}function r(...e){let n=0;for(let t=0;t<e.length;t++){const a=e[t],i=a.data?a.data.length/a.channels:0;n=Math.max(n,i)}const t=[];for(let a=0;a<n;a++)for(let n=0;n<e.length;n++){const{data:i=[],channels:o}=e[n];for(let e=0;e<o;e++)t.push(i[a*o+e])}return t}function s(e){let t=0,a=0;const i=[],o=new Map;for(const r of e){if(!r.visible)continue;const e=r.geometry.isBufferGeometry?l(r.geometry,["position","normal","uv"]):(new n.BufferGeometry).fromGeometry(r.geometry);e.getIndex()||f(e),e.applyMatrix4?e.applyMatrix4(r.matrixWorld):e.applyMatrix(r.matrixWorld),e.getAttribute("normal")?e.normalizeNormals():e.computeVertexNormals(),t+=e.getAttribute("position").count,a+=e.getIndex().count;const s=r.material;let d=o.get(s);void 0===d&&(d=o.size,o.set(s,d)),i.push({geometry:e,materialIndex:d})}const r=function(e,t,a){const i=new n.BufferAttribute(new Float32Array(3*t),3,!1),o=new n.BufferAttribute(new Float32Array(3*t),3,!1),r=new n.BufferAttribute(new Float32Array(2*t),2,!1),s=new n.BufferAttribute(new Int32Array(2*t),2,!1),l=new n.BufferAttribute(new Uint32Array(a),1,!1),f=new n.BufferGeometry;"function"!=typeof f.setAttribute&&(f.setAttribute=f.addAttribute);f.setAttribute("position",i),f.setAttribute("normal",o),f.setAttribute("uv",r),f.setAttribute("materialMeshIndex",s),f.setIndex(l);let d=0,c=0,u=1;for(const{geometry:n,materialIndex:t}of e){const e=n.getAttribute("position").count;f.merge(n,d);const a=n.getIndex();for(let e=0;e<a.count;e++)l.setX(c+e,d+a.getX(e));for(let n=0;n<e;n++)s.setXY(d+n,t,u);d+=e,c+=a.count,u++}return f}(i,t,a);return{geometry:r,materials:Array.from(o.keys())}}function l(e,t){const a=new n.BufferGeometry;for(const n of t){const t=e.getAttribute(n);t&&("function"!=typeof a.setAttribute&&(a.setAttribute=a.addAttribute),a.setAttribute(n,t.clone()))}const i=e.getIndex();return i&&a.setIndex(i),a}function f(e){const t=e.getAttribute("position");if(!t)return void console.warn("No position attribute");const a=new Uint32Array(t.count);for(let e=0;e<a.length;e++)a[e]=e;return e.setIndex(new n.BufferAttribute(a,1,!1)),e}function d(e,n,t){return Math.min(Math.max(e,n),t)}function c(e,n){let{width:t=null,height:a=null,data:i=null,length:o=1,channels:r=null,storage:s=null,flipY:l=!1,gammaCorrection:f=!1,wrapS:c=e.CLAMP_TO_EDGE,wrapT:p=e.CLAMP_TO_EDGE,minFilter:m=e.NEAREST,magFilter:L=e.NEAREST}=n;t=t||i.width||0,a=a||i.height||0;const x=e.createTexture();let h,v;Array.isArray(i)&&(v=i,i=v[0]),h=v||o>1?e.TEXTURE_2D_ARRAY:e.TEXTURE_2D,e.activeTexture(e.TEXTURE0),e.bindTexture(h,x),e.texParameteri(h,e.TEXTURE_WRAP_S,c),e.texParameteri(h,e.TEXTURE_WRAP_T,p),e.texParameteri(h,e.TEXTURE_MIN_FILTER,m),e.texParameteri(h,e.TEXTURE_MAG_FILTER,L),r||(r=i&&i.length?i.length/(t*a):4),r=d(r,1,4);const{type:A,format:_,internalFormat:g}=function(e,n,t,a,i){let o,r;const s=a instanceof Uint8Array||a instanceof HTMLImageElement||a instanceof HTMLCanvasElement||a instanceof ImageData||a instanceof ImageBitmap,l=a instanceof Float32Array;"byte"===t||!t&&s?(r={1:e.R8,2:e.RG8,3:i?e.SRGB8:e.RGB8,4:i?e.SRGB8_ALPHA8:e.RGBA8}[n],o=e.UNSIGNED_BYTE):"float"===t||!t&&l?(r={1:e.R32F,2:e.RG32F,3:e.RGB32F,4:e.RGBA32F}[n],o=e.FLOAT):"halfFloat"===t?(r={1:e.R16F,2:e.RG16F,3:e.RGB16F,4:e.RGBA16F}[n],o=e.HALF_FLOAT):"snorm"===t&&(r={1:e.R8_SNORM,2:e.RG8_SNORM,3:e.RGB8_SNORM,4:e.RGBA8_SNORM}[n],o=e.UNSIGNED_BYTE);return{format:u(e,n),internalFormat:r,type:o}}(e,r,s,i,f);if(v){e.texStorage3D(h,1,g,t,a,v.length);for(let n=0;n<v.length;n++){const i=v[n].width||t,o=v[n].height||a;e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,Array.isArray(l)?l[n]:l),e.texSubImage3D(h,0,0,0,n,i,o,1,_,A,v[n])}}else o>1?e.texStorage3D(h,1,g,t,a,o):(e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,l),e.texStorage2D(h,1,g,t,a),i&&e.texSubImage2D(h,0,0,0,t,a,_,A,i));return e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!1),{target:h,texture:x}}function u(e,n){return{1:e.RED,2:e.RG,3:e.RGB,4:e.RGBA}[n]}function p(e){let n,t,a,i,o,r=-1,s=1,l=0,f=0,c=function(e){const n=e.getParameter(e.MAX_RENDERBUFFER_SIZE);if(n<=8192)return 2e5;if(16384===n)return 4e5;if(n>=32768)return 6e5}(e);function u(){r=-1,o=NaN}function p(){const e=l/f;n=Math.ceil(l/Math.round(l/Math.sqrt(c*e))),t=Math.ceil(n/e),a=Math.ceil(l/n),i=Math.ceil(f/t),s=a*i}return{nextTile:function(e){r++,o+=e,r%s==0&&(o&&(!function(){const e=o/s,n=21-e;c+=5e3*Math.sign(n)*Math.sqrt(Math.abs(e)),c=d(c,8192,l*f)}(),p()),o=0,r=0);const u=r===s-1,m=r%a,L=Math.floor(r/a)%i;return{x:m*n,y:L*t,tileWidth:n,tileHeight:t,isFirstTile:0===r,isLastTile:u}},reset:u,setSize:function(e,n){l=e,f=n,u(),p()}}}function m(e,n){const t={};for(const a of n)t[a]=e.getExtension(a);return t}function L(e,n){const t={},a=e.getProgramParameter(n,e.ACTIVE_ATTRIBUTES);for(let i=0;i<a;i++){const{name:a}=e.getActiveAttrib(n,i);a&&(t[a]=e.getAttribLocation(n,a))}return t}let x;function h(e,n){const t=function(e,n){const t={},a=e.getProgramParameter(n,e.ACTIVE_UNIFORMS);for(let i=0;i<a;i++){const{name:a,type:o}=e.getActiveUniform(n,i),r=e.getUniformLocation(n,a);r&&(t[a]={type:o,location:r})}return t}(e,n),a={},i=[];for(let e in t){const{type:n,location:i}=t[e],o={type:n,location:i,v0:0,v1:0,v2:0,v3:0};a[e]=o}const o=new Set;return x=x||function(e){return{[e.FLOAT]:v(1,"f"),[e.FLOAT_VEC2]:v(2,"f"),[e.FLOAT_VEC3]:v(3,"f"),[e.FLOAT_VEC4]:v(4,"f"),[e.INT]:v(1,"i"),[e.INT_VEC2]:v(2,"i"),[e.INT_VEC3]:v(3,"i"),[e.INT_VEC4]:v(4,"i"),[e.SAMPLER_2D]:v(1,"i"),[e.SAMPLER_2D_ARRAY]:v(1,"i"),[e.FLOAT_MAT2]:A(2,2),[e.FLOAT_MAT3]:A(3,3),[e.FLOAT_MAT4]:A(4,4)}}(e),{setUniform:function(e,n,t,r,s){const l=a[e];l?(l.v0=n,l.v1=t,l.v2=r,l.v3=s,i.push(l)):o.has(e)||o.add(e)},upload:function(){for(;i.length>0;){const{type:n,location:t,v0:a,v1:o,v2:r,v3:s}=i.pop(),l=x[n];if(a.length)if(l.matrix){const n=a,i=o||!1;e[l.matrix](t,i,n)}else e[l.array](t,a);else e[l.values](t,a,o,r,s)}}}}function v(e,n){return{values:`uniform${e}${n}`,array:`uniform${e}${n}v`}}function A(e,n){return{matrix:e===n?`uniformMatrix${e}fv`:`uniformMatrix${e}x${n}fv`}}function _(e,n){const{fragment:t,vertex:a}=n,i=a instanceof WebGLShader?a:g(e,n),o=t instanceof WebGLShader?t:function(e,{defines:n,fragment:t}){return F(e,e.FRAGMENT_SHADER,t,n)}(e,n),r=function(e,n,t,a,i){const o=e.createProgram();if(e.attachShader(o,n),e.attachShader(o,t),a&&e.transformFeedbackVaryings(o,a,i),e.linkProgram(o),e.detachShader(o,n),e.detachShader(o,t),e.getProgramParameter(o,e.LINK_STATUS))return o;throw e.getProgramInfoLog(o)}(e,i,o);return{...S(e,r),outputLocs:t.outputs?M(t.outputs):{}}}function g(e,{defines:n,vertex:t}){return F(e,e.VERTEX_SHADER,t,n)}function S(e,n){const t=h(e,n),a={};let i=1;function o(){for(let n in a){const{tex:t,unit:i}=a[n];e.activeTexture(e.TEXTURE0+i),e.bindTexture(t.target,t.texture)}}return{attribLocs:L(e,n),bindTextures:o,program:n,setTexture:function(e,n){if(n)if(a[e])a[e].tex=n;else{const o=i++;t.setUniform(e,o),a[e]={unit:o,tex:n}}},setUniform:t.setUniform,textures:a,useProgram:function(a=!0){e.useProgram(n),t.upload(),a&&o()}}}function F(e,n,t,a){let i="#version 300 es\nprecision mediump float;\nprecision mediump int;\nprecision lowp isampler2D;\n";return a&&(i+=function(e){let n="";for(const t in e){const a=e[t];a&&(n+=`#define ${t} ${a}\n`)}return n}(a)),n===e.FRAGMENT_SHADER&&t.outputs&&(i+=function(e){let n="";const t=M(e);for(let e in t){n+=`layout(location = ${t[e]}) out vec4 out_${e};\n`}return n}(t.outputs)),t.includes&&(i+=function(e,n){let t="";for(let a of e)t+="function"==typeof a?a(n):a;return t}(t.includes,a)),"function"==typeof t.source?i+=t.source(a):i+=t.source,function(e,n,t){const a=e.createShader(n);if(e.shaderSource(a,t),e.compileShader(a),e.getShaderParameter(a,e.COMPILE_STATUS))return a;const i=t.split("\n").map(((e,n)=>`${n+1}: ${e}`)).join("\n");throw console.log(i),e.getShaderInfoLog(a)}(e,n,i)}function M(e){let n={};for(let t=0;t<e.length;t++)n[e[t]]=t;return n}var T={source:"\n    layout(location = 0) in vec2 a_position;\n\n    out vec2 vCoord;\n\n    void main() {\n      vCoord = a_position;\n      gl_Position = vec4(2. * a_position - 1., 0, 1);\n    }\n  "};var I={source:"\n        layout(location = 0) out vec4 out_color;\n        uniform sampler2D inputBuffer;\n        uniform vec2 resolution;\n        in vec2 vCoord;\n        #define FXAA_PC 1\n        #define FXAA_GLSL_100 1\n        #define FXAA_QUALITY_PRESET 12\n        #define FXAA_GREEN_AS_LUMA 1\n        #ifndef FXAA_PC_CONSOLE\n        #define FXAA_PC_CONSOLE 0\n        #endif\n        #ifndef FXAA_GLSL_120\n        #define FXAA_GLSL_120 0\n        #endif\n        #ifndef FXAA_GLSL_130\n        #define FXAA_GLSL_130 0\n        #endif\n        #ifndef FXAA_HLSL_3\n        #define FXAA_HLSL_3 0\n        #endif\n        #ifndef FXAA_HLSL_4\n        #define FXAA_HLSL_4 0\n        #endif\n        #ifndef FXAA_HLSL_5\n        #define FXAA_HLSL_5 0\n        #endif\n        #ifndef FXAA_GREEN_AS_LUMA\n        #define FXAA_GREEN_AS_LUMA 0\n        #endif\n        #ifndef FXAA_EARLY_EXIT\n        #define FXAA_EARLY_EXIT 1\n        #endif\n        #ifndef FXAA_DISCARD\n        #define FXAA_DISCARD 0\n        #endif\n        #ifndef FXAA_FAST_PIXEL_OFFSET\n        #ifdef GL_EXT_gpu_shader4\n        #define FXAA_FAST_PIXEL_OFFSET 1\n        #endif\n        #ifdef GL_NV_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n        #endif\n        #ifdef GL_ARB_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n        #endif\n        #ifndef FXAA_FAST_PIXEL_OFFSET\n        #define FXAA_FAST_PIXEL_OFFSET 0\n        #endif\n        #endif\n        #ifndef FXAA_GATHER4_ALPHA\n        #if (FXAA_HLSL_5 == 1)\n        #define FXAA_GATHER4_ALPHA 1\n        #endif\n        #ifdef GL_ARB_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n        #endif\n        #ifdef GL_NV_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n        #endif\n        #ifndef FXAA_GATHER4_ALPHA\n        #define FXAA_GATHER4_ALPHA 0\n        #endif\n        #endif\n        /*============================================================================FXAA QUALITY-TUNING KNOBS------------------------------------------------------------------------------NOTE the other tuning knobs are now in the shader function inputs!============================================================================*/\n        #ifndef FXAA_QUALITY_PRESET\n        #define FXAA_QUALITY_PRESET 12\n        #endif\n        /*============================================================================FXAA QUALITY-PRESETS============================================================================*//*============================================================================FXAA QUALITY-MEDIUM DITHER PRESETS============================================================================*/\n        #if (FXAA_QUALITY_PRESET == 10)\n        #define FXAA_QUALITY_PS 3\n        #define FXAA_QUALITY_P0 1.5\n        #define FXAA_QUALITY_P1 3.0\n        #define FXAA_QUALITY_P2 12.0\n        #endif\n        #if (FXAA_QUALITY_PRESET == 11)\n        #define FXAA_QUALITY_PS 4\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 3.0\n        #define FXAA_QUALITY_P3 12.0\n        #endif\n        #if (FXAA_QUALITY_PRESET == 12)\n        #define FXAA_QUALITY_PS 5\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 4.0\n        #define FXAA_QUALITY_P4 12.0\n        #endif\n        #if (FXAA_QUALITY_PRESET == 13)\n        #define FXAA_QUALITY_PS 6\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 4.0\n        #define FXAA_QUALITY_P5 12.0\n        #endif\n        #if (FXAA_QUALITY_PRESET == 14)\n        #define FXAA_QUALITY_PS 7\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 4.0\n        #define FXAA_QUALITY_P6 12.0\n        #endif\n        #if (FXAA_QUALITY_PRESET == 15)\n        #define FXAA_QUALITY_PS 8\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 4.0\n        #define FXAA_QUALITY_P7 12.0\n        #endif\n        /*============================================================================FXAA QUALITY-LOW DITHER PRESETS============================================================================*/\n        #if (FXAA_QUALITY_PRESET == 20)\n        #define FXAA_QUALITY_PS 3\n        #define FXAA_QUALITY_P0 1.5\n        #define FXAA_QUALITY_P1 2.0\n        #define FXAA_QUALITY_P2 8.0\n        #endif\n        #if (FXAA_QUALITY_PRESET == 21)\n        #define FXAA_QUALITY_PS 4\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 8.0\n        #endif\n        #if (FXAA_QUALITY_PRESET == 22)\n        #define FXAA_QUALITY_PS 5\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 8.0\n        #endif\n        #if (FXAA_QUALITY_PRESET == 23)\n        #define FXAA_QUALITY_PS 6\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 8.0\n        #endif\n        #if (FXAA_QUALITY_PRESET == 24)\n        #define FXAA_QUALITY_PS 7\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 3.0\n        #define FXAA_QUALITY_P6 8.0\n        #endif\n        #if (FXAA_QUALITY_PRESET == 25)\n        #define FXAA_QUALITY_PS 8\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 4.0\n        #define FXAA_QUALITY_P7 8.0\n        #endif\n        #if (FXAA_QUALITY_PRESET == 26)\n        #define FXAA_QUALITY_PS 9\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 4.0\n        #define FXAA_QUALITY_P8 8.0\n        #endif\n        #if (FXAA_QUALITY_PRESET == 27)\n        #define FXAA_QUALITY_PS 10\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 2.0\n        #define FXAA_QUALITY_P8 4.0\n        #define FXAA_QUALITY_P9 8.0\n        #endif\n        #if (FXAA_QUALITY_PRESET == 28)\n        #define FXAA_QUALITY_PS 11\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 2.0\n        #define FXAA_QUALITY_P8 2.0\n        #define FXAA_QUALITY_P9 4.0\n        #define FXAA_QUALITY_P10 8.0\n        #endif\n        #if (FXAA_QUALITY_PRESET == 29)\n        #define FXAA_QUALITY_PS 12\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.5\n        #define FXAA_QUALITY_P2 2.0\n        #define FXAA_QUALITY_P3 2.0\n        #define FXAA_QUALITY_P4 2.0\n        #define FXAA_QUALITY_P5 2.0\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 2.0\n        #define FXAA_QUALITY_P8 2.0\n        #define FXAA_QUALITY_P9 2.0\n        #define FXAA_QUALITY_P10 4.0\n        #define FXAA_QUALITY_P11 8.0\n        #endif\n        /*============================================================================FXAA QUALITY-EXTREME QUALITY============================================================================*/\n        #if (FXAA_QUALITY_PRESET == 39)\n        #define FXAA_QUALITY_PS 12\n        #define FXAA_QUALITY_P0 1.0\n        #define FXAA_QUALITY_P1 1.0\n        #define FXAA_QUALITY_P2 1.0\n        #define FXAA_QUALITY_P3 1.0\n        #define FXAA_QUALITY_P4 1.0\n        #define FXAA_QUALITY_P5 1.5\n        #define FXAA_QUALITY_P6 2.0\n        #define FXAA_QUALITY_P7 2.0\n        #define FXAA_QUALITY_P8 2.0\n        #define FXAA_QUALITY_P9 2.0\n        #define FXAA_QUALITY_P10 4.0\n        #define FXAA_QUALITY_P11 8.0\n        #endif\n        /*============================================================================API PORTING============================================================================*/\n        #if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n        #define FxaaBool bool\n        #define FxaaDiscard discard\n        #define FxaaFloat float\n        #define FxaaFloat2 vec2\n        #define FxaaFloat3 vec3\n        #define FxaaFloat4 vec4\n        #define FxaaHalf float\n        #define FxaaHalf2 vec2\n        #define FxaaHalf3 vec3\n        #define FxaaHalf4 vec4\n        #define FxaaInt2 ivec2\n        #define FxaaSat(x) clamp(x, 0.0, 1.0)\n        #define FxaaTex sampler2D\n        #else\n        #define FxaaBool bool\n        #define FxaaDiscard clip(-1)\n        #define FxaaFloat float\n        #define FxaaFloat2 float2\n        #define FxaaFloat3 float3\n        #define FxaaFloat4 float4\n        #define FxaaHalf half\n        #define FxaaHalf2 half2\n        #define FxaaHalf3 half3\n        #define FxaaHalf4 half4\n        #define FxaaSat(x) saturate(x)\n        #endif\n        #if (FXAA_GLSL_100 == 1)\n        #define FxaaTexTop(t, p) texture(t, p, 0.0)\n        #define FxaaTexOff(t, p, o, r) texture(t, p + (o * r), 0.0)\n        #endif\n        #if (FXAA_GLSL_120 == 1)\n        #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n        #if (FXAA_FAST_PIXEL_OFFSET == 1)\n        #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n        #else\n        #define FxaaTexOff(t, p, o, r) textureLod(t, p + (o * r), 0.0)\n        #endif\n        #if (FXAA_GATHER4_ALPHA == 1)\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n        #endif\n        #endif\n        #if (FXAA_GLSL_130 == 1)\n        #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n        #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n        #if (FXAA_GATHER4_ALPHA == 1)\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n        #endif\n        #endif\n        #if (FXAA_HLSL_3 == 1)\n        #define FxaaInt2 float2\n        #define FxaaTex sampler2D\n        #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n        #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n        #endif\n        #if (FXAA_HLSL_4 == 1)\n        #define FxaaInt2 int2\n        struct FxaaTex {\n            SamplerState smpl;\n            texture tex;\n        };\n        #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n        #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n        #endif\n        #if (FXAA_HLSL_5 == 1)\n        #define FxaaInt2 int2\n        struct FxaaTex {\n            SamplerState smpl;\n            texture tex;\n        };\n        #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n        #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n        #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n        #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n        #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n        #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n        #endif\n        /*============================================================================GREEN AS LUMA OPTION SUPPORT FUNCTION============================================================================*/\n        #if (FXAA_GREEN_AS_LUMA == 0)\n        FxaaFloat FxaaLuma(FxaaFloat4 rgba) {\n            return rgba.w;\n        }\n        #else\n        FxaaFloat FxaaLuma(FxaaFloat4 rgba) {\n            return rgba.y;\n        }\n        #endif\n        /*============================================================================FXAA3 QUALITY-PC============================================================================*/\n        #if (FXAA_PC == 1)\n        FxaaFloat4 FxaaPixelShader(FxaaFloat2 pos, FxaaFloat4 fxaaConsolePosPos, FxaaTex tex, FxaaTex fxaaConsole360TexExpBiasNegOne, FxaaTex fxaaConsole360TexExpBiasNegTwo, FxaaFloat2 fxaaQualityRcpFrame, FxaaFloat4 fxaaConsoleRcpFrameOpt, FxaaFloat4 fxaaConsoleRcpFrameOpt2, FxaaFloat4 fxaaConsole360RcpFrameOpt2, FxaaFloat fxaaQualitySubpix, FxaaFloat fxaaQualityEdgeThreshold, FxaaFloat fxaaQualityEdgeThresholdMin, FxaaFloat fxaaConsoleEdgeSharpness, FxaaFloat fxaaConsoleEdgeThreshold, FxaaFloat fxaaConsoleEdgeThresholdMin, FxaaFloat4 fxaaConsole360ConstDir) {\n            FxaaFloat2 posM;\n            posM.x = pos.x;\n            posM.y = pos.y;\n        #if (FXAA_GATHER4_ALPHA == 1)\n        #if (FXAA_DISCARD == 0)\n            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n        #if (FXAA_GREEN_AS_LUMA == 0)\n        #define lumaM rgbyM.w\n        #else\n        #define lumaM rgbyM.y\n        #endif\n        #endif\n        #if (FXAA_GREEN_AS_LUMA == 0)\n            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n        #else\n            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n        #endif\n        #if (FXAA_DISCARD == 1)\n        #define lumaM luma4A.w\n        #endif\n        #define lumaE luma4A.z\n        #define lumaS luma4A.x\n        #define lumaSE luma4A.y\n        #define lumaNW luma4B.w\n        #define lumaN luma4B.z\n        #define lumaW luma4B.x\n        #else\n            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n        #if (FXAA_GREEN_AS_LUMA == 0)\n        #define lumaM rgbyM.w\n        #else\n        #define lumaM rgbyM.y\n        #endif\n        #if (FXAA_GLSL_100 == 1)\n            FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0, 1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 0.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(0.0, -1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n        #else\n            FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0, 1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(0, -1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n        #endif\n        #endif\n            FxaaFloat maxSM = max(lumaS, lumaM);\n            FxaaFloat minSM = min(lumaS, lumaM);\n            FxaaFloat maxESM = max(lumaE, maxSM);\n            FxaaFloat minESM = min(lumaE, minSM);\n            FxaaFloat maxWN = max(lumaN, lumaW);\n            FxaaFloat minWN = min(lumaN, lumaW);\n            FxaaFloat rangeMax = max(maxWN, maxESM);\n            FxaaFloat rangeMin = min(minWN, minESM);\n            FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n            FxaaFloat range = rangeMax - rangeMin;\n            FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n            FxaaBool earlyExit = range < rangeMaxClamped;\n            if(earlyExit)\n        #if (FXAA_DISCARD == 1)\n                FxaaDiscard;\n        #else\n            return rgbyM;\n        #endif\n        #if (FXAA_GATHER4_ALPHA == 0)\n        #if (FXAA_GLSL_100 == 1)\n            FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, -1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, 1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(1.0, -1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n        #else\n            FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, -1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, 1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n        #endif\n        #else\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n        #endif\n            FxaaFloat lumaNS = lumaN + lumaS;\n            FxaaFloat lumaWE = lumaW + lumaE;\n            FxaaFloat subpixRcpRange = 1.0 / range;\n            FxaaFloat subpixNSWE = lumaNS + lumaWE;\n            FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n            FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n            FxaaFloat lumaNESE = lumaNE + lumaSE;\n            FxaaFloat lumaNWNE = lumaNW + lumaNE;\n            FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n            FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n            FxaaFloat lumaNWSW = lumaNW + lumaSW;\n            FxaaFloat lumaSWSE = lumaSW + lumaSE;\n            FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n            FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n            FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n            FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n            FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n            FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n            FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n            FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n            FxaaBool horzSpan = edgeHorz >= edgeVert;\n            FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n            if(!horzSpan)\n                lumaN = lumaW;\n            if(!horzSpan)\n                lumaS = lumaE;\n            if(horzSpan)\n                lengthSign = fxaaQualityRcpFrame.y;\n            FxaaFloat subpixB = (subpixA * (1.0 / 12.0)) - lumaM;\n            FxaaFloat gradientN = lumaN - lumaM;\n            FxaaFloat gradientS = lumaS - lumaM;\n            FxaaFloat lumaNN = lumaN + lumaM;\n            FxaaFloat lumaSS = lumaS + lumaM;\n            FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n            FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n            if(pairN)\n                lengthSign = -lengthSign;\n            FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n            FxaaFloat2 posB;\n            posB.x = posM.x;\n            posB.y = posM.y;\n            FxaaFloat2 offNP;\n            offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n            offNP.y = (horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n            if(!horzSpan)\n                posB.x += lengthSign * 0.5;\n            if(horzSpan)\n                posB.y += lengthSign * 0.5;\n            FxaaFloat2 posN;\n            posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n            posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n            FxaaFloat2 posP;\n            posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n            posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n            FxaaFloat subpixD = ((-2.0) * subpixC) + 3.0;\n            FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n            FxaaFloat subpixE = subpixC * subpixC;\n            FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n            if(!pairN)\n                lumaNN = lumaSS;\n            FxaaFloat gradientScaled = gradient * 1.0 / 4.0;\n            FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n            FxaaFloat subpixF = subpixD * subpixE;\n            FxaaBool lumaMLTZero = lumaMM < 0.0;\n            lumaEndN -= lumaNN * 0.5;\n            lumaEndP -= lumaNN * 0.5;\n            FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n            FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN)\n                posN.x -= offNP.x * FXAA_QUALITY_P1;\n            if(!doneN)\n                posN.y -= offNP.y * FXAA_QUALITY_P1;\n            FxaaBool doneNP = (!doneN) || (!doneP);\n            if(!doneP)\n                posP.x += offNP.x * FXAA_QUALITY_P1;\n            if(!doneP)\n                posP.y += offNP.y * FXAA_QUALITY_P1;\n            if(doneNP) {\n                if(!doneN)\n                    lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP)\n                    lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN)\n                    lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP)\n                    lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN)\n                    posN.x -= offNP.x * FXAA_QUALITY_P2;\n                if(!doneN)\n                    posN.y -= offNP.y * FXAA_QUALITY_P2;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP)\n                    posP.x += offNP.x * FXAA_QUALITY_P2;\n                if(!doneP)\n                    posP.y += offNP.y * FXAA_QUALITY_P2;\n        #if (FXAA_QUALITY_PS > 3)\n                if(doneNP) {\n                    if(!doneN)\n                        lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP)\n                        lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN)\n                        lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP)\n                        lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN)\n                        posN.x -= offNP.x * FXAA_QUALITY_P3;\n                    if(!doneN)\n                        posN.y -= offNP.y * FXAA_QUALITY_P3;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP)\n                        posP.x += offNP.x * FXAA_QUALITY_P3;\n                    if(!doneP)\n                        posP.y += offNP.y * FXAA_QUALITY_P3;\n        #if (FXAA_QUALITY_PS > 4)\n                    if(doneNP) {\n                        if(!doneN)\n                            lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP)\n                            lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN)\n                            lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP)\n                            lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN)\n                            posN.x -= offNP.x * FXAA_QUALITY_P4;\n                        if(!doneN)\n                            posN.y -= offNP.y * FXAA_QUALITY_P4;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP)\n                            posP.x += offNP.x * FXAA_QUALITY_P4;\n                        if(!doneP)\n                            posP.y += offNP.y * FXAA_QUALITY_P4;\n        #if (FXAA_QUALITY_PS > 5)\n                        if(doneNP) {\n                            if(!doneN)\n                                lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if(!doneP)\n                                lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if(!doneN)\n                                lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP)\n                                lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN)\n                                posN.x -= offNP.x * FXAA_QUALITY_P5;\n                            if(!doneN)\n                                posN.y -= offNP.y * FXAA_QUALITY_P5;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP)\n                                posP.x += offNP.x * FXAA_QUALITY_P5;\n                            if(!doneP)\n                                posP.y += offNP.y * FXAA_QUALITY_P5;\n        #if (FXAA_QUALITY_PS > 6)\n                            if(doneNP) {\n                                if(!doneN)\n                                    lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                if(!doneP)\n                                    lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                if(!doneN)\n                                    lumaEndN = lumaEndN - lumaNN * 0.5;\n                                if(!doneP)\n                                    lumaEndP = lumaEndP - lumaNN * 0.5;\n                                doneN = abs(lumaEndN) >= gradientScaled;\n                                doneP = abs(lumaEndP) >= gradientScaled;\n                                if(!doneN)\n                                    posN.x -= offNP.x * FXAA_QUALITY_P6;\n                                if(!doneN)\n                                    posN.y -= offNP.y * FXAA_QUALITY_P6;\n                                doneNP = (!doneN) || (!doneP);\n                                if(!doneP)\n                                    posP.x += offNP.x * FXAA_QUALITY_P6;\n                                if(!doneP)\n                                    posP.y += offNP.y * FXAA_QUALITY_P6;\n        #if (FXAA_QUALITY_PS > 7)\n                                if(doneNP) {\n                                    if(!doneN)\n                                        lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                    if(!doneP)\n                                        lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                    if(!doneN)\n                                        lumaEndN = lumaEndN - lumaNN * 0.5;\n                                    if(!doneP)\n                                        lumaEndP = lumaEndP - lumaNN * 0.5;\n                                    doneN = abs(lumaEndN) >= gradientScaled;\n                                    doneP = abs(lumaEndP) >= gradientScaled;\n                                    if(!doneN)\n                                        posN.x -= offNP.x * FXAA_QUALITY_P7;\n                                    if(!doneN)\n                                        posN.y -= offNP.y * FXAA_QUALITY_P7;\n                                    doneNP = (!doneN) || (!doneP);\n                                    if(!doneP)\n                                        posP.x += offNP.x * FXAA_QUALITY_P7;\n                                    if(!doneP)\n                                        posP.y += offNP.y * FXAA_QUALITY_P7;\n        #if (FXAA_QUALITY_PS > 8)\n                                    if(doneNP) {\n                                        if(!doneN)\n                                            lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                        if(!doneP)\n                                            lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                        if(!doneN)\n                                            lumaEndN = lumaEndN - lumaNN * 0.5;\n                                        if(!doneP)\n                                            lumaEndP = lumaEndP - lumaNN * 0.5;\n                                        doneN = abs(lumaEndN) >= gradientScaled;\n                                        doneP = abs(lumaEndP) >= gradientScaled;\n                                        if(!doneN)\n                                            posN.x -= offNP.x * FXAA_QUALITY_P8;\n                                        if(!doneN)\n                                            posN.y -= offNP.y * FXAA_QUALITY_P8;\n                                        doneNP = (!doneN) || (!doneP);\n                                        if(!doneP)\n                                            posP.x += offNP.x * FXAA_QUALITY_P8;\n                                        if(!doneP)\n                                            posP.y += offNP.y * FXAA_QUALITY_P8;\n        #if (FXAA_QUALITY_PS > 9)\n                                        if(doneNP) {\n                                            if(!doneN)\n                                                lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                            if(!doneP)\n                                                lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                            if(!doneN)\n                                                lumaEndN = lumaEndN - lumaNN * 0.5;\n                                            if(!doneP)\n                                                lumaEndP = lumaEndP - lumaNN * 0.5;\n                                            doneN = abs(lumaEndN) >= gradientScaled;\n                                            doneP = abs(lumaEndP) >= gradientScaled;\n                                            if(!doneN)\n                                                posN.x -= offNP.x * FXAA_QUALITY_P9;\n                                            if(!doneN)\n                                                posN.y -= offNP.y * FXAA_QUALITY_P9;\n                                            doneNP = (!doneN) || (!doneP);\n                                            if(!doneP)\n                                                posP.x += offNP.x * FXAA_QUALITY_P9;\n                                            if(!doneP)\n                                                posP.y += offNP.y * FXAA_QUALITY_P9;\n        #if (FXAA_QUALITY_PS > 10)\n                                            if(doneNP) {\n                                                if(!doneN)\n                                                    lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                                if(!doneP)\n                                                    lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                                if(!doneN)\n                                                    lumaEndN = lumaEndN - lumaNN * 0.5;\n                                                if(!doneP)\n                                                    lumaEndP = lumaEndP - lumaNN * 0.5;\n                                                doneN = abs(lumaEndN) >= gradientScaled;\n                                                doneP = abs(lumaEndP) >= gradientScaled;\n                                                if(!doneN)\n                                                    posN.x -= offNP.x * FXAA_QUALITY_P10;\n                                                if(!doneN)\n                                                    posN.y -= offNP.y * FXAA_QUALITY_P10;\n                                                doneNP = (!doneN) || (!doneP);\n                                                if(!doneP)\n                                                    posP.x += offNP.x * FXAA_QUALITY_P10;\n                                                if(!doneP)\n                                                    posP.y += offNP.y * FXAA_QUALITY_P10;\n        #if (FXAA_QUALITY_PS > 11)\n                                                if(doneNP) {\n                                                    if(!doneN)\n                                                        lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                                    if(!doneP)\n                                                        lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                                    if(!doneN)\n                                                        lumaEndN = lumaEndN - lumaNN * 0.5;\n                                                    if(!doneP)\n                                                        lumaEndP = lumaEndP - lumaNN * 0.5;\n                                                    doneN = abs(lumaEndN) >= gradientScaled;\n                                                    doneP = abs(lumaEndP) >= gradientScaled;\n                                                    if(!doneN)\n                                                        posN.x -= offNP.x * FXAA_QUALITY_P11;\n                                                    if(!doneN)\n                                                        posN.y -= offNP.y * FXAA_QUALITY_P11;\n                                                    doneNP = (!doneN) || (!doneP);\n                                                    if(!doneP)\n                                                        posP.x += offNP.x * FXAA_QUALITY_P11;\n                                                    if(!doneP)\n                                                        posP.y += offNP.y * FXAA_QUALITY_P11;\n        #if (FXAA_QUALITY_PS > 12)\n                                                    if(doneNP) {\n                                                        if(!doneN)\n                                                            lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                                                        if(!doneP)\n                                                            lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                                                        if(!doneN)\n                                                            lumaEndN = lumaEndN - lumaNN * 0.5;\n                                                        if(!doneP)\n                                                            lumaEndP = lumaEndP - lumaNN * 0.5;\n                                                        doneN = abs(lumaEndN) >= gradientScaled;\n                                                        doneP = abs(lumaEndP) >= gradientScaled;\n                                                        if(!doneN)\n                                                            posN.x -= offNP.x * FXAA_QUALITY_P12;\n                                                        if(!doneN)\n                                                            posN.y -= offNP.y * FXAA_QUALITY_P12;\n                                                        doneNP = (!doneN) || (!doneP);\n                                                        if(!doneP)\n                                                            posP.x += offNP.x * FXAA_QUALITY_P12;\n                                                        if(!doneP)\n                                                            posP.y += offNP.y * FXAA_QUALITY_P12;\n                                                    }\n        #endif\n                                                }\n        #endif\n                                            }\n        #endif\n                                        }\n        #endif\n                                    }\n        #endif\n                                }\n        #endif\n                            }\n        #endif\n                        }\n        #endif\n                    }\n        #endif\n                }\n        #endif\n            }\n            FxaaFloat dstN = posM.x - posN.x;\n            FxaaFloat dstP = posP.x - posM.x;\n            if(!horzSpan)\n                dstN = posM.y - posN.y;\n            if(!horzSpan)\n                dstP = posP.y - posM.y;\n            FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n            FxaaFloat spanLength = (dstP + dstN);\n            FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n            FxaaFloat spanLengthRcp = 1.0 / spanLength;\n            FxaaBool directionN = dstN < dstP;\n            FxaaFloat dst = min(dstN, dstP);\n            FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n            FxaaFloat subpixG = subpixF * subpixF;\n            FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n            FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n            FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n            FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n            if(!horzSpan)\n                posM.x += pixelOffsetSubpix * lengthSign;\n            if(horzSpan)\n                posM.y += pixelOffsetSubpix * lengthSign;\n        #if (FXAA_DISCARD == 1)\n            return FxaaTexTop(tex, posM);\n        #else\n            return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n        #endif\n        }\n        #endif\n        void main() {\n            out_color = FxaaPixelShader(vCoord, vec4(0.0), inputBuffer, inputBuffer, inputBuffer, resolution, vec4(0.0), vec4(0.0), vec4(0.0), 0.75, 0.166, 0.0833, 0.0, 0.0, 0.0, vec4(0.0));\n            out_color.a = texture(inputBuffer, vCoord).a;\n        }\n    "};function G(e,{color:n,depth:t}){const a=e.createFramebuffer();function i(){e.bindFramebuffer(e.FRAMEBUFFER,a)}function o(){e.bindFramebuffer(e.FRAMEBUFFER,null)}return function(){i();const a=[];for(let t in n){t=Number(t),void 0===t&&console.error("invalid location");const i=n[t];e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0+t,i.target,i.texture,0),a.push(e.COLOR_ATTACHMENT0+t)}e.drawBuffers(a),t&&e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,t.target,t.texture),o()}(),{color:n,bind:i,unbind:o}}var N={source:"\n        vec4 LGL_An(sampler2D map, vec2 uv) {\n        #ifdef OES_texture_float_linear\n            return texture(map, uv);\n        #else\n            vec2 size = vec2(textureSize(map, 0));\n            vec2 texelSize = 1.0 / size;\n            uv = uv * size - 0.5;\n            vec2 f = fract(uv);\n            uv = floor(uv) + 0.5;\n            vec4 s1 = texture(map, (uv + vec2(0, 0)) * texelSize);\n            vec4 s2 = texture(map, (uv + vec2(1, 0)) * texelSize);\n            vec4 s3 = texture(map, (uv + vec2(0, 1)) * texelSize);\n            vec4 s4 = texture(map, (uv + vec2(1, 1)) * texelSize);\n            return mix(mix(s1, s2, f.x), mix(s3, s4, f.x), f.y);\n        #endif\n        }\n        layout(location = 0) out vec4 out_color;\n        in vec2 vCoord;\n        uniform sampler2D lightTex;\n        uniform sampler2D LGL_AsDataTex;\n        uniform sampler2D gPosition;\n        uniform sampler2D gNormal;\n        uniform sampler2D gColor;\n        uniform float colorFactor;\n        uniform float normalFactor;\n        uniform float positionFactor;\n        uniform float stepwidth;\n        uniform int level;\n        uniform float useMomentVariance;\n        uniform float demodulateAlbedo;\n        float LGL_Ap(float v) {\n            return acos(min(max(v, 0.0), 1.0));\n        }\n        float LGL_Aq(vec2 uv) {\n            return max(texture(LGL_AsDataTex, uv).a, 0.);\n        }\n        vec4 LGL_Ar() {\n            vec4 upscaledLight = texture(lightTex, vCoord);\n            float sampleFrame = upscaledLight.a;\n            float sf2 = sampleFrame * sampleFrame;\n            vec3 color = upscaledLight.rgb / upscaledLight.a;\n            vec3 normal = texture(gNormal, vCoord).rgb;\n            vec4 positionAndMeshIndex = texture(gPosition, vCoord);\n            vec3 position = positionAndMeshIndex.rgb;\n            float meshIndex = positionAndMeshIndex.w;\n            bool isBG = meshIndex > 0.0 ? false : true;\n            if(isBG) {\n                return upscaledLight;\n            }\n            vec2 size = vec2(textureSize(lightTex, 0));\n            int kernelRadius = 9;\n            float dx = 1. / size.x;\n            float dy = 1. / size.y;\n            float kernel[9] = float[9] (1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0, 1.0 / 8.0, 1.0 / 4.0, 1.0 / 8.0, 1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0);\n            vec2 offset[9] = vec2[9] (vec2(-dx, -dy), vec2(0, -dy), vec2(dx, -dy), vec2(-dx, 0), vec2(0, 0), vec2(dx, 0), vec2(-dx, dy), vec2(0, dy), vec2(dx, dy));\n            vec3 colorSum = vec3(0.);\n            float weightSum = 0.;\n            float var;\n            float varSum;\n            float varSumWeight;\n            if(useMomentVariance > 0.) {\n                for(int i = 0; i < kernelRadius; i++) {\n                    vec2 uv = vCoord + offset[i];\n                    if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n                        continue;\n                    }\n                    vec4 positionAndMeshIndex = texture(gPosition, uv);\n                    float meshIndex = positionAndMeshIndex.w;\n                    bool isBG = meshIndex > 0.0 ? false : true;\n                    if(isBG) {\n                        continue;\n                    }\n                    varSum += kernel[i] * LGL_Aq(uv);\n                    varSumWeight += kernel[i];\n                }\n                if(varSumWeight > 0.0) {\n                    var = max(varSum / varSumWeight, 0.0);\n                } else {\n                    var = max(LGL_Aq(vCoord), 0.0);\n                }\n            }\n            for(int i = 0; i < kernelRadius; i++) {\n                vec2 uv = vCoord + offset[i] * float(stepwidth);\n                if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n                    continue;\n                }\n                vec4 positionAndMeshIndex = texture(gPosition, uv);\n                float meshIndex = positionAndMeshIndex.w;\n                bool isBG = meshIndex > 0.0 ? false : true;\n                if(isBG) {\n                    continue;\n                }\n                vec4 upscaledLight = texture(lightTex, uv);\n                vec3 kernelColor = upscaledLight.rgb / upscaledLight.a;\n                float Dc = distance(color, kernelColor);\n                float Wc;\n                if(useMomentVariance > 0.) {\n                    Wc = min(exp(-Dc / ((1. + sqrt(var)) * colorFactor + 1e-6)), 1.0);\n                } else {\n                    Wc = min(exp(-Dc / (colorFactor + 1e-6)), 1.0);\n                }\n                vec3 kernelNormal = texture(gNormal, uv).rgb;\n                float Dn = dot(normal, kernelNormal);\n                Dn = Dn / float(stepwidth * stepwidth + 1e-6);\n                if(Dn < 1e-3) {\n                    continue;\n                }\n                float Wn = Dn;\n                vec3 kernelPosition = positionAndMeshIndex.rgb;\n                float Dp = distance(position, kernelPosition);\n                float Wp = min(exp(-Dp / (positionFactor + 1e-6)), 1.0);\n                float weight = Wc * Wn * Wp * kernel[i];\n                weightSum += weight;\n                colorSum += kernelColor * weight;\n            }\n            colorSum = colorSum / weightSum;\n            return vec4(colorSum * sampleFrame, sampleFrame);\n        }\n        void main() {\n            vec4 light = LGL_Ar();\n            out_color = light;\n        }\n    "};function b(e,n){const{fullscreenQuad:t}=n;let a,i,o=.5,r=.2,s=.35;function l(){let e=a;a=i,i=e}const f={gl:e,vertex:t.vertexShader,fragment:N},d=_(e,f);return{draw:function(n){let{light:f,reprojectData:c}=n;for(let n=0;n<3;n++)d.setUniform("level",n),d.setUniform("colorFactor",1/(1<<n)*o),d.setUniform("normalFactor",1/(1<<n)*r),d.setUniform("positionFactor",1/(1<<n)*s),d.setUniform("stepwidth",(1<<n+1)-1),0===n?d.setTexture("lightTex",f):d.setTexture("lightTex",i.color[0]),c?(d.setUniform("useMomentVariance",1),d.setTexture("reprojectDataTex",c)):(d.setUniform("useMomentVariance",0),d.setTexture("reprojectDataTex",null)),a.bind(),e.clear(e.COLOR_BUFFER_BIT),e.viewport(0,0,e.drawingBufferWidth,e.drawingBufferHeight),d.useProgram(),t.draw(),a.unbind(),l();return i},setGBuffers:function({position:e,normal:n,color:t}){d.setTexture("gPosition",e),d.setTexture("gNormal",n),d.setTexture("gColor",t)},setColorFactor:function(e){o=e},setNormalFactor:function(e){r=e},setPositionFactor:function(e){s=e},setDemodulateAlbedo:function(e){d.setUniform("demodulateAlbedo",e)},getDenoiseFactors:function(){return{colorFactor:o,normalFactor:r,positionFactor:s}},setSize:function(n,t){!function(n,t){const o=()=>G(e,{color:{0:c(e,{width:n,height:t,storage:"float",magFilter:e.NEAREST,minFilter:e.NEAREST})}});a=o(),i=o()}(n,t)}}}function P(e,n,t){const a=e[t];e[t]=e[n],e[n]=a}const y=new n.Vector3;function R(e){const t=function(e){const t=[],a=e.getIndex?e.getIndex().array:e.index.array,i=e.getAttribute?e.getAttribute("position"):e.attributes.position,o=e.getAttribute?e.getAttribute("materialMeshIndex"):e.attributes.materialMeshIndex,r=new n.Vector3,s=new n.Vector3,l=new n.Vector3,f=new n.Vector3,d=new n.Vector3;for(let e=0;e<a.length;e+=3){const c=a[e],u=a[e+1],p=a[e+2],m=new n.Box3;i.getX?(r.fromBufferAttribute(i,c),s.fromBufferAttribute(i,u),l.fromBufferAttribute(i,p)):(r.x=i.array[c*i.itemSize],r.y=i.array[c*i.itemSize+1],r.z=i.array[c*i.itemSize+2],s.x=i.array[u*i.itemSize],s.y=i.array[u*i.itemSize+1],s.z=i.array[u*i.itemSize+2],l.x=i.array[p*i.itemSize],l.y=i.array[p*i.itemSize+1],l.z=i.array[p*i.itemSize+2]),f.subVectors(l,r),d.subVectors(s,r),m.expandByPoint(r),m.expandByPoint(s),m.expandByPoint(l);const L=m.getCenter(new n.Vector3),x={bounds:m,center:L,indices:[c,u,p],faceNormal:(new n.Vector3).crossVectors(d,f).normalize(),materialIndex:o.getX?o.getX(c):o.array[c*o.itemSize]};t.push(x)}return t}(e);return E(t,0,t.length)}function E(e,t,a){const i=new n.Box3;for(let n=t;n<a;n++)i.union(e[n].bounds);const o=a-t;if(1===o)return U(e.slice(t,a),i);{const f=new n.Box3;for(let n=t;n<a;n++)f.expandByPoint(e[n].center);const d=(f.getSize(y),y.x>y.z?y.x>y.y?"x":"y":y.z>y.y?"z":"y");let c=Math.floor((t+a)/2);if(o<=4)!function(e,n,t=0,a=e.length,i=Math.floor((t+a)/2)){for(let o=t;o<=i;o++){let t=o,i=e[o];for(let r=o+1;r<a;r++)n(i,e[r])||(t=r,i=e[r],P(e,o,t))}}(e,((e,n)=>e.center[d]<n.center[d]),t,a,c);else{if(f.max[d]===f.min[d])return U(e.slice(t,a),i);{const o=[];for(let e=0;e<12;e++)o.push({bounds:new n.Box3,count:0});for(let n=t;n<a;n++){let t=Math.floor(o.length*X(f,d,e[n].center));t===o.length&&(t=o.length-1),o[t].count++,o[t].bounds.union(e[n].bounds)}const r=[];for(let e=0;e<o.length-1;e++){const t=new n.Box3,a=new n.Box3;let s=0,l=0;for(let n=0;n<=e;n++)t.union(o[n].bounds),s+=o[n].count;for(let n=e+1;n<o.length;n++)a.union(o[n].bounds),l+=o[n].count;r.push(.1+(s*B(t)+l*B(a))/B(i))}let s=r[0],l=0;for(let e=1;e<r.length;e++)r[e]<s&&(s=r[e],l=e);c=function(e,n,t=0,a=e.length){for(;t!==a;){for(;n(e[t]);)if(++t===a)return t;do{if(t===--a)return t}while(!n(e[a]));P(e,t,a),t++}return t}(e,(e=>{let n=Math.floor(o.length*X(f,d,e.center));return n===o.length&&(n=o.length-1),n<=l}),t,a)}}return r=d,s=E(e,t,c),l=E(e,c,a),{child0:s,child1:l,bounds:(new n.Box3).union(s.bounds).union(l.bounds),splitAxis:r}}var r,s,l}function U(e,n){return{primitives:e,bounds:n}}function X(e,n,t){let a=t[n]-e.min[n];return e.max[n]>e.min[n]&&(a/=e.max[n]-e.min[n]),a}function B(e){return e.getSize(y),2*(y.x*y.z+y.x*y.y+y.z*y.y)}function V(e,n=!0){return n&&window.Worker?(new w).build(e):new Promise((n=>{const t=function(e){const n=[],t=[],a={x:0,y:1,z:2};let i=1;const o=(e,r=1)=>{if(i=Math.max(r,i),e.primitives)for(let a=0;a<e.primitives.length;a++){const i=e.primitives[a];n.push(i.indices[0],i.indices[1],i.indices[2],e.primitives.length,i.faceNormal.x,i.faceNormal.y,i.faceNormal.z,i.materialIndex),t.push(!1)}else{const i=e.bounds;n.push(i.min.x,i.min.y,i.min.z,a[e.splitAxis],i.max.x,i.max.y,i.max.z,null);const s=n.length-1;t.push(!0),o(e.child0,r+1),n[s]=n.length/4,o(e.child1,r+1)}};o(e);const r=new ArrayBuffer(4*n.length),s=new Float32Array(r),l=new Int32Array(r);for(let e=0;e<t.length;e++){let a=8*e;t[e]?(s[a]=n[a],s[a+1]=n[a+1],s[a+2]=n[a+2],l[a+3]=n[a+3]):(l[a]=n[a],l[a+1]=n[a+1],l[a+2]=n[a+2],l[a+3]=-n[a+3]),s[a+4]=n[a+4],s[a+5]=n[a+5],s[a+6]=n[a+6],l[a+7]=n[a+7]}return{maxDepth:i,count:n.length/4,buffer:s}}(R(e));n(t)}))}const z="IWZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIHR7Y29uc3RydWN0b3IodD0wLGU9MCxpPTApe3RoaXMueD10LHRoaXMueT1lLHRoaXMuej1pfWxlbmd0aCgpe3JldHVybiBNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnopfWFkZFZlY3RvcnModCxlKXtyZXR1cm4gdGhpcy54PXQueCtlLngsdGhpcy55PXQueStlLnksdGhpcy56PXQueitlLnosdGhpc31zdWJWZWN0b3JzKHQsZSl7cmV0dXJuIHRoaXMueD10LngtZS54LHRoaXMueT10LnktZS55LHRoaXMuej10LnotZS56LHRoaXN9bXVsdGlwbHlTY2FsYXIodCl7cmV0dXJuIHRoaXMueCo9dCx0aGlzLnkqPXQsdGhpcy56Kj10LHRoaXN9ZGl2aWRlKHQpe3JldHVybiB0aGlzLngvPXQueCx0aGlzLnkvPXQueSx0aGlzLnovPXQueix0aGlzfWRpdmlkZVNjYWxhcih0KXtyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigxL3QpfW1pbih0KXtyZXR1cm4gdGhpcy54PU1hdGgubWluKHRoaXMueCx0LngpLHRoaXMueT1NYXRoLm1pbih0aGlzLnksdC55KSx0aGlzLno9TWF0aC5taW4odGhpcy56LHQueiksdGhpc31tYXgodCl7cmV0dXJuIHRoaXMueD1NYXRoLm1heCh0aGlzLngsdC54KSx0aGlzLnk9TWF0aC5tYXgodGhpcy55LHQueSksdGhpcy56PU1hdGgubWF4KHRoaXMueix0LnopLHRoaXN9ZG90KHQpe3JldHVybiB0aGlzLngqdC54K3RoaXMueSp0LnkrdGhpcy56KnQuen1ub3JtYWxpemUoKXtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKXx8MSl9Y3Jvc3NWZWN0b3JzKHQsZSl7Y29uc3QgaT10Lngsbj10Lnkscj10Lnoscz1lLngsbz1lLnksaD1lLno7cmV0dXJuIHRoaXMueD1uKmgtcipvLHRoaXMueT1yKnMtaSpoLHRoaXMuej1pKm8tbipzLHRoaXN9ZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LGUsaSl7cmV0dXJuIHZvaWQgMCE9PWkmJmNvbnNvbGUud2FybigiVEhSRUUuVmVjdG9yMzogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLiIpLHRoaXMueD10LmdldFgoZSksdGhpcy55PXQuZ2V0WShlKSx0aGlzLno9dC5nZXRaKGUpLHRoaXN9fWNsYXNzIGV7Y29uc3RydWN0b3IoZT1uZXcgdCgxLzAsMS8wLDEvMCksaT1uZXcgdCgtMS8wLC0xLzAsLTEvMCkpe3RoaXMubWluPWUsdGhpcy5tYXg9aX1pc0VtcHR5KCl7cmV0dXJuIHRoaXMubWF4Lng8dGhpcy5taW4ueHx8dGhpcy5tYXgueTx0aGlzLm1pbi55fHx0aGlzLm1heC56PHRoaXMubWluLnp9Z2V0Q2VudGVyKHQpe3JldHVybiB0aGlzLmlzRW1wdHkoKT90LnNldCgwLDAsMCk6dC5hZGRWZWN0b3JzKHRoaXMubWluLHRoaXMubWF4KS5tdWx0aXBseVNjYWxhciguNSl9Z2V0U2l6ZSh0KXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/dC5zZXQoMCwwLDApOnQuc3ViVmVjdG9ycyh0aGlzLm1heCx0aGlzLm1pbil9ZXhwYW5kQnlQb2ludCh0KXtyZXR1cm4gdGhpcy5taW4ubWluKHQpLHRoaXMubWF4Lm1heCh0KSx0aGlzfXVuaW9uKHQpe3JldHVybiB0aGlzLm1pbi5taW4odC5taW4pLHRoaXMubWF4Lm1heCh0Lm1heCksdGhpc319ZnVuY3Rpb24gaSh0LGUsaSl7Y29uc3Qgbj10W2ldO3RbaV09dFtlXSx0W2VdPW59Y29uc3Qgbj1uZXcgdDtmdW5jdGlvbiByKHQsZSl7cmV0dXJue3ByaW1pdGl2ZXM6dCxib3VuZHM6ZX19ZnVuY3Rpb24gcyh0LGUsaSl7bGV0IG49aVtlXS10Lm1pbltlXTtyZXR1cm4gdC5tYXhbZV0+dC5taW5bZV0mJihuLz10Lm1heFtlXS10Lm1pbltlXSksbn1mdW5jdGlvbiBvKHQpe3JldHVybiB0LmdldFNpemUobiksMioobi54Km4ueituLngqbi55K24ueipuLnkpfWZ1bmN0aW9uIGgodCxhLHUpe2NvbnN0IGw9bmV3IGU7Zm9yKGxldCBlPWE7ZTx1O2UrKylsLnVuaW9uKHRbZV0uYm91bmRzKTtjb25zdCBjPXUtYTtpZigxPT09YylyZXR1cm4gcih0LnNsaWNlKGEsdSksbCk7e2NvbnN0IHk9bmV3IGU7Zm9yKGxldCBlPWE7ZTx1O2UrKyl5LmV4cGFuZEJ5UG9pbnQodFtlXS5jZW50ZXIpO2NvbnN0IHo9KHkuZ2V0U2l6ZShuKSxuLng+bi56P24ueD5uLnk/IngiOiJ5IjpuLno+bi55PyJ6IjoieSIpO2xldCBkPU1hdGguZmxvb3IoKGErdSkvMik7aWYoYzw9NCkhZnVuY3Rpb24odCxlLG49MCxyPXQubGVuZ3RoLHM9TWF0aC5mbG9vcigobityKS8yKSl7Zm9yKGxldCBvPW47bzw9cztvKyspe2xldCBuPW8scz10W29dO2ZvcihsZXQgaD1vKzE7aDxyO2grKyllKHMsdFtoXSl8fChuPWgscz10W2hdLGkodCxvLG4pKX19KHQsKCh0LGUpPT50LmNlbnRlclt6XTxlLmNlbnRlclt6XSksYSx1LGQpO2Vsc2V7aWYoeS5tYXhbel09PT15Lm1pblt6XSlyZXR1cm4gcih0LnNsaWNlKGEsdSksbCk7e2NvbnN0IG49MTIscj1bXTtmb3IobGV0IHQ9MDt0PG47dCsrKXIucHVzaCh7Ym91bmRzOm5ldyBlLGNvdW50OjB9KTtmb3IobGV0IGU9YTtlPHU7ZSsrKXtsZXQgaT1NYXRoLmZsb29yKG4qcyh5LHosdFtlXS5jZW50ZXIpKTtpPT09ci5sZW5ndGgmJihpPXIubGVuZ3RoLTEpLHJbaV0uY291bnQrKyxyW2ldLmJvdW5kcy51bmlvbih0W2VdLmJvdW5kcyl9Y29uc3QgaD1bXTtmb3IobGV0IHQ9MDt0PHIubGVuZ3RoLTE7dCsrKXtjb25zdCBpPW5ldyBlLG49bmV3IGU7bGV0IHM9MCxhPTA7Zm9yKGxldCBlPTA7ZTw9dDtlKyspaS51bmlvbihyW2VdLmJvdW5kcykscys9cltlXS5jb3VudDtmb3IobGV0IGU9dCsxO2U8ci5sZW5ndGg7ZSsrKW4udW5pb24ocltlXS5ib3VuZHMpLGErPXJbZV0uY291bnQ7aC5wdXNoKC4xKyhzKm8oaSkrYSpvKG4pKS9vKGwpKX1sZXQgYz1oWzBdLG09MDtmb3IobGV0IHQ9MTt0PGgubGVuZ3RoO3QrKyloW3RdPGMmJihjPWhbdF0sbT10KTtkPWZ1bmN0aW9uKHQsZSxuPTAscj10Lmxlbmd0aCl7Zm9yKDtuIT09cjspe2Zvcig7ZSh0W25dKTspaWYoKytuPT09cilyZXR1cm4gbjtkb3tpZihuPT09LS1yKXJldHVybiBufXdoaWxlKCFlKHRbcl0pKTtpKHQsbixyKSxuKyt9cmV0dXJuIG59KHQsKHQ9PntsZXQgZT1NYXRoLmZsb29yKHIubGVuZ3RoKnMoeSx6LHQuY2VudGVyKSk7cmV0dXJuIGU9PT1yLmxlbmd0aCYmKGU9ci5sZW5ndGgtMSksZTw9bX0pLGEsdSl9fXJldHVybiBtPXoseD1oKHQsYSxkKSxmPWgodCxkLHUpLHtjaGlsZDA6eCxjaGlsZDE6Zixib3VuZHM6KG5ldyBlKS51bmlvbih4LmJvdW5kcykudW5pb24oZi5ib3VuZHMpLHNwbGl0QXhpczptfX12YXIgbSx4LGZ9ZnVuY3Rpb24gYShpKXtjb25zdCBuPWZ1bmN0aW9uKGkpe2NvbnN0IG49W10scj1pLmdldEluZGV4P2kuZ2V0SW5kZXgoKS5hcnJheTppLmluZGV4LmFycmF5LHM9aS5nZXRBdHRyaWJ1dGU/aS5nZXRBdHRyaWJ1dGUoInBvc2l0aW9uIik6aS5hdHRyaWJ1dGVzLnBvc2l0aW9uLG89aS5nZXRBdHRyaWJ1dGU/aS5nZXRBdHRyaWJ1dGUoIm1hdGVyaWFsTWVzaEluZGV4Iik6aS5hdHRyaWJ1dGVzLm1hdGVyaWFsTWVzaEluZGV4LGg9bmV3IHQsYT1uZXcgdCx1PW5ldyB0LGw9bmV3IHQsYz1uZXcgdDtmb3IobGV0IG09MDttPHIubGVuZ3RoO20rPTMpe2NvbnN0IGk9clttXSx4PXJbbSsxXSxmPXJbbSsyXSx5PW5ldyBlO3MuZ2V0WD8oaC5mcm9tQnVmZmVyQXR0cmlidXRlKHMsaSksYS5mcm9tQnVmZmVyQXR0cmlidXRlKHMseCksdS5mcm9tQnVmZmVyQXR0cmlidXRlKHMsZikpOihoLng9cy5hcnJheVtpKnMuaXRlbVNpemVdLGgueT1zLmFycmF5W2kqcy5pdGVtU2l6ZSsxXSxoLno9cy5hcnJheVtpKnMuaXRlbVNpemUrMl0sYS54PXMuYXJyYXlbeCpzLml0ZW1TaXplXSxhLnk9cy5hcnJheVt4KnMuaXRlbVNpemUrMV0sYS56PXMuYXJyYXlbeCpzLml0ZW1TaXplKzJdLHUueD1zLmFycmF5W2Yqcy5pdGVtU2l6ZV0sdS55PXMuYXJyYXlbZipzLml0ZW1TaXplKzFdLHUuej1zLmFycmF5W2Yqcy5pdGVtU2l6ZSsyXSkseS5leHBhbmRCeVBvaW50KGgpLHkuZXhwYW5kQnlQb2ludChhKSx5LmV4cGFuZEJ5UG9pbnQodSksbC5zdWJWZWN0b3JzKHUsaCksYy5zdWJWZWN0b3JzKGEsaCk7Y29uc3Qgej0obmV3IHQpLmNyb3NzVmVjdG9ycyhjLGwpLm5vcm1hbGl6ZSgpLGQ9e2JvdW5kczp5LGNlbnRlcjp5LmdldENlbnRlcihuZXcgdCksaW5kaWNlczpbaSx4LGZdLGZhY2VOb3JtYWw6eixtYXRlcmlhbEluZGV4Om8uZ2V0WD9vLmdldFgoaSk6by5hcnJheVtpKm8uaXRlbVNpemVdfTtuLnB1c2goZCl9cmV0dXJuIG59KGkpO3JldHVybiBoKG4sMCxuLmxlbmd0aCl9c2VsZi5vbm1lc3NhZ2U9ZnVuY3Rpb24oe2RhdGE6dH0pe2NvbnN0e2dlb21ldHJ5OmV9PXQ7dHJ5e2NvbnN0IHQ9ZnVuY3Rpb24odCl7Y29uc3QgZT1bXSxpPVtdLG49e3g6MCx5OjEsejoyfTtsZXQgcj0xO2NvbnN0IHM9KHQsbz0xKT0+e2lmKHI9TWF0aC5tYXgobyxyKSx0LnByaW1pdGl2ZXMpZm9yKGxldCBuPTA7bjx0LnByaW1pdGl2ZXMubGVuZ3RoO24rKyl7Y29uc3Qgcj10LnByaW1pdGl2ZXNbbl07ZS5wdXNoKHIuaW5kaWNlc1swXSxyLmluZGljZXNbMV0sci5pbmRpY2VzWzJdLHQucHJpbWl0aXZlcy5sZW5ndGgsci5mYWNlTm9ybWFsLngsci5mYWNlTm9ybWFsLnksci5mYWNlTm9ybWFsLnosci5tYXRlcmlhbEluZGV4KSxpLnB1c2goITEpfWVsc2V7Y29uc3Qgcj10LmJvdW5kcztlLnB1c2goci5taW4ueCxyLm1pbi55LHIubWluLnosblt0LnNwbGl0QXhpc10sci5tYXgueCxyLm1heC55LHIubWF4LnosbnVsbCk7Y29uc3QgaD1lLmxlbmd0aC0xO2kucHVzaCghMCkscyh0LmNoaWxkMCxvKzEpLGVbaF09ZS5sZW5ndGgvNCxzKHQuY2hpbGQxLG8rMSl9fTtzKHQpO2NvbnN0IG89bmV3IEFycmF5QnVmZmVyKDQqZS5sZW5ndGgpLGg9bmV3IEZsb2F0MzJBcnJheShvKSxhPW5ldyBJbnQzMkFycmF5KG8pO2ZvcihsZXQgdT0wO3U8aS5sZW5ndGg7dSsrKXtsZXQgdD04KnU7aVt1XT8oaFt0XT1lW3RdLGhbdCsxXT1lW3QrMV0saFt0KzJdPWVbdCsyXSxhW3QrM109ZVt0KzNdKTooYVt0XT1lW3RdLGFbdCsxXT1lW3QrMV0sYVt0KzJdPWVbdCsyXSxhW3QrM109LWVbdCszXSksaFt0KzRdPWVbdCs0XSxoW3QrNV09ZVt0KzVdLGhbdCs2XT1lW3QrNl0sYVt0KzddPWVbdCs3XX1yZXR1cm57bWF4RGVwdGg6cixjb3VudDplLmxlbmd0aC80LGJ1ZmZlcjpofX0oYShlKSk7c2VsZi5wb3N0TWVzc2FnZSh7ZXJyb3I6bnVsbCxmbGF0dGVuZWRCdmg6dH0pfWNhdGNoKGkpe3NlbGYucG9zdE1lc3NhZ2Uoe2Vycm9yOmksZmxhdHRlbmVkQnZoOm51bGx9KX19fSgpOwo=",C="undefined"!=typeof window&&window.Blob&&new Blob([atob(z)],{type:"text/javascript;charset=utf-8"});class w{constructor(){this.worker=function(){const e=C&&(window.URL||window.webkitURL).createObjectURL(C);try{return e?new Worker(e):new Worker("data:application/javascript;base64,"+z,{type:"module"})}finally{e&&(window.URL||window.webkitURL).revokeObjectURL(e)}}(),this.building=!1}build(e){if(this.building)throw new Error("BVHWorker is building");return this.building=!0,new Promise(((n,t)=>{this.worker.onmessage=e=>{this.building=!1,this.worker.onmessage=null;const{flattenedBvh:a,error:i}=e.data;i?t(new Error(i)):n(a)},this.worker.postMessage({geometry:e})}))}}function Q(e){let n;if(n={width:e.data.image.width,height:e.data.image.height,data:e.data.image.data,dataFormat:"float"},e.data.type===a.UnsignedByteType)n.data?n.data=function(e,n=1){const t=e.length/4,a=new Float32Array(3*t),i=[];for(let e=0;e<255;e++)i[e]=n*Math.pow(2,e-128)/255;for(let n=0;n<t;n++){const t=e[4*n],o=e[4*n+1],r=e[4*n+2],s=i[e[4*n+3]];a[3*n]=t*s,a[3*n+1]=o*s,a[3*n+2]=r*s}return a}(n.data,e.intensity):(n.data=function(e){const n=document.createElement("canvas"),t=n.getContext("2d");n.width=e.width,n.height=e.height,t.drawImage(e,0,0);const{data:a}=t.getImageData(0,0,n.width,n.height);return a}(e.data.image),n.dataFormat="byte");else if(e.data.type===a.FloatType&&e.data.format===a.RGBAFormat){const t=e.data.image.data,a=t.length/4,i=new Float32Array(3*a);for(let e=0;e<a;e++)i[3*e+0]=t[4*e+0],i[3*e+1]=t[4*e+1],i[3*e+2]=t[4*e+2];n.data=i}else e.data.type==a.HalfFloatType?console.error("Please use 'new RGBELoader().setDataType(THREE.FloatType)' to load hdr env map. Half-Float type will loss of precision and have an impression of the effect."):e.data.type!==a.FloatType&&console.error(`No support environmentLight's data type: ${e.data.type.toString()}`);return n}function D(e){const n=e.data,t={width:e.width+2,height:e.height+1},a=function(e,n,t){const a=new Float32Array(t*e*n);return{set(n,i,o,r){a[t*(i*e+n)+o]=r},get:(n,i,o)=>a[t*(i*e+n)+o],width:e,height:n,channels:t,array:a}}(t.width,t.height,2);for(let i=0;i<e.height;i++){const o=Math.sin(Math.PI*(i+.5)/e.height);for(let t=0;t<e.width;t++){const r=3*(i*e.width+t);let s=.2126*n[r]+.7152*n[r+1]+.0722*n[r+2];s*=o,a.set(t+2,i,0,a.get(t+1,i,0)+s/e.width),a.set(t+1,i,1,s)}const r=a.get(t.width-1,i,0);for(let e=1;e<a.width;e++)a.set(e,i,0,a.get(e,i,0)/r),a.set(e,i,1,a.get(e,i,1)/r);a.set(0,i+1,0,a.get(0,i,0)+r/e.height),a.set(0,i,1,r)}const i=a.get(0,a.height-1,0);for(let e=0;e<a.height;e++)a.set(0,e,0,a.get(0,e,0)/i),a.set(0,e,1,a.get(0,e,1)/i);return t.data=a.array,t}function Y(e,n){const t=[],a=e**n;for(let e=0;e<a;e++)t[e]=e;let i=t.length;const o=[];function r(){i=0}return{next:function(){i>=t.length&&(!function(e){for(let n=e.length-1;n>0;n--){const t=Math.floor(Math.random()*(n+1)),a=e[n];e[n]=e[t],e[t]=a}}(t),r());let a=t[i++];for(let t=0;t<n;t++)o[t]=a%e+Math.random(),a=Math.floor(a/e);return o},restart:r,strataCount:e}}function W(e,n){const t=[];for(const a of n)t.push(Y(e,a));const a=[];return{next:function(){let e=0;for(const n of t){const t=n.next();for(const n of t)a[e++]=n}return a},restart:function(){for(const e of t)e.restart()},strataCount:e}}var H={source:e=>"\n      #define PI 3.14159265359\n      #define TWOPI 6.28318530718\n      #define INVPI 0.31830988618\n      #define INVPI2 0.10132118364\n      #define EPS 0.0001\n      #define ONE_MINUS_EPS 0.999999\n      #define INF 1000000.0\n      #define ROUGHNESS_MIN 0.001\n      #define DISNEY 0\n      const vec3 luminance = vec3(0.2126, 0.7152, 0.0722);\n      float LGL_AV(vec3 color) {\n          return dot(color, luminance);\n      }\n      #define RAY_MAX_DISTANCE 9999.0\n      struct Ray {\n          vec3 o;\n          vec3 d;\n          vec3 LGL_BN;\n          float LGL_BO;\n      };\n      struct Path {\n          Ray ray;\n          vec3 li;\n          float alpha;\n          vec3 beta;\n          bool LGL_BQ;\n          float LGL_BR;\n          vec3 LGL_BS;\n      };\n      struct Camera {\n          mat4 transform;\n          float aspect;\n          float fov;\n          float focus;\n          float aperture;\n      };\n      #if defined(NUM_LIGHTS)\n      struct Lights {\n          vec3 position[NUM_LIGHTS];\n          vec3 emission[NUM_LIGHTS];\n          vec3 p1[NUM_LIGHTS];\n          vec3 p2[NUM_LIGHTS];\n          vec4 params[NUM_LIGHTS];\n      };\n      struct Light {\n          vec3 position;\n          vec3 emission;\n          vec3 p1;\n          vec3 p2;\n          float radius;\n          float area;\n          float type;\n          float visible;\n      };\n      #endif\n      struct SurfaceInteraction {\n          bool LGL_BK;\n          bool LGL_BI;\n          float t;\n          vec3 position;\n          vec3 normal;\n          vec3 LGL_BM;\n          vec3 LGL_BL;\n          vec3 tangent;\n          vec3 bitangent;\n          vec3 color;\n          vec3 extinction;\n          vec3 emissive;\n          int LGL_BH;\n          float roughness;\n          float metalness;\n          float LGL_BF;\n          float LGL_BB;\n          float LGL_Ay;\n          float sheen;\n          float LGL_Az;\n          float clearcoat;\n          float LGL_BA;\n          float LGL_BC;\n          float ior;\n          float LGL_BE;\n          float eta;\n          float LGL_BD;\n          vec3 specularColor;\n          float LGL_BG;\n      };\n      struct BsdfSampleRec {\n          vec3 L;\n          vec3 f;\n          float pdf;\n      };\n      struct LightSampleRec {\n          vec3 normal;\n          vec3 emission;\n          vec3 direction;\n          float dist;\n          float pdf;\n      };\n      void LGL_AW(inout Ray ray, vec3 origin, vec3 direction) {\n          ray.o = origin;\n          ray.d = direction;\n          ray.LGL_BN = 1.0 / ray.d;\n          ray.LGL_BO = RAY_MAX_DISTANCE;\n      }\n      void LGL_AW(inout Ray ray, vec3 origin, vec3 direction, float rMax) {\n          ray.o = origin;\n          ray.d = direction;\n          ray.LGL_BN = 1.0 / ray.d;\n          ray.LGL_BO = rMax;\n      }\n      ivec2 LGL_AX(int i, int LGL_BT) {\n          ivec2 u;\n          u.y = i >> LGL_BT;\n          u.x = i - (u.y << LGL_BT);\n          return u;\n      }\n      vec4 LGL_AY(sampler2D s, int i, int LGL_BT) {\n          return texelFetch(s, LGL_AX(i, LGL_BT), 0);\n      }\n      ivec4 LGL_AY(isampler2D s, int i, int LGL_BT) {\n          return texelFetch(s, LGL_AX(i, LGL_BT), 0);\n      }\n      uniform Camera camera;\n      uniform vec2 pixelSize;\n      uniform vec2 jitter;\n      uniform float frameCount;\n      in vec2 vCoord;\n      #if defined(NUM_LIGHTS)\n      uniform Lights lights;\n      #endif\n      uniform int bounces;\n      uniform vec3 backgroundColor;\n      uniform float envMapIntensity;\n      uniform float enviromentVisible;\n      uniform sampler2D noiseTex;\n      uniform float stratifiedSamples[71];\n      uniform float strataSize;\n      float pixelSeed;\n      float LGL_AN(vec2 p) {\n          return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n      }\n      uvec4 seed;\n      ivec2 pixel;\n      void LGL_AO(float frame) {\n          pixel = ivec2(vCoord / pixelSize);\n          seed = uvec4(pixel, int(frame), pixel.x + pixel.y);\n      }\n      void LGL_AP(inout uvec4 v) {\n          v = v * 1664525u + 1013904223u;\n          v.x += v.y * v.w;\n          v.y += v.z * v.x;\n          v.z += v.x * v.y;\n          v.w += v.y * v.z;\n          v = v ^ (v >> 16u);\n          v.x += v.y * v.w;\n          v.y += v.z * v.x;\n          v.z += v.x * v.y;\n          v.w += v.y * v.z;\n      }\n      float LGL_AQ() {\n          LGL_AP(seed);\n          return float(seed.x) / float(0xffffffffu);\n      }\n      vec2 LGL_AQ2() {\n          LGL_AP(seed);\n          return vec2(seed.xy) / float(0xffffffffu);\n      }\n      void LGL_AS(float frame) {\n          vec2 noiseSize = vec2(textureSize(noiseTex, 0));\n          pixelSeed = texture(noiseTex, vCoord / (pixelSize * noiseSize)).r;\n          LGL_AO(frame);\n      }\n      int sampleIndex = 0;\n      float LGL_AQomSample() {\n          float stratifiedSample = stratifiedSamples[sampleIndex++];\n          float LGL_AQom = fract((stratifiedSample + pixelSeed) * strataSize);\n          return EPS + (1.0 - 2.0 * EPS) * LGL_AQom;\n      }\n      vec2 LGL_AQomSampleVec2() {\n          return vec2(LGL_AQomSample(), LGL_AQomSample());\n      }\n      struct MaterialSamples {\n          vec2 s1;\n          vec2 s2;\n          vec2 s3;\n          vec2 s4;\n      };\n      MaterialSamples getRandomMaterialSamples() {\n          MaterialSamples samples;\n          samples.s1 = LGL_AQomSampleVec2();\n          samples.s2 = LGL_AQomSampleVec2();\n          samples.s3 = LGL_AQomSampleVec2();\n          samples.s4 = LGL_AQomSampleVec2();\n          return samples;\n      }\n      vec4 LGL_An(sampler2D map, vec2 uv) {\n      #ifdef OES_texture_float_linear\n          return texture(map, uv);\n      #else\n          vec2 size = vec2(textureSize(map, 0));\n          vec2 texelSize = 1.0 / size;\n          uv = uv * size - 0.5;\n          vec2 f = fract(uv);\n          uv = floor(uv) + 0.5;\n          vec4 s1 = texture(map, (uv + vec2(0, 0)) * texelSize);\n          vec4 s2 = texture(map, (uv + vec2(1, 0)) * texelSize);\n          vec4 s3 = texture(map, (uv + vec2(0, 1)) * texelSize);\n          vec4 s4 = texture(map, (uv + vec2(1, 1)) * texelSize);\n          return mix(mix(s1, s2, f.x), mix(s3, s4, f.x), f.y);\n      #endif\n      }\n      uniform Materials {\n          vec4 colorAndMaterialType[NUM_MATERIALS];\n          vec4 roughnessMetalnessNormalScale[NUM_MATERIALS];\n          vec4 alphaSpecularTintSheenSheenTint[NUM_MATERIALS];\n          vec4 clearcoaRoughnessSubfaceTransmission[NUM_MATERIALS];\n          vec4 iorAtDistanceAnisotropicWorkflow[NUM_MATERIALS];\n          vec4 extinction[NUM_MATERIALS];\n          vec4 specularColorGlossiness[NUM_MATERIALS];\n      #if defined(NUM_DIFFUSE_MAPS) || defined(NUM_NORMAL_MAPS) || defined(NUM_PBR_MAPS)\n          ivec4 diffuseNormalRoughnessMetalnessMapIndex[NUM_MATERIALS];\n      #endif\n      #if defined(NUM_EMISSIVE_MAPS) || defined(NUM_PBR_SG_MAPS)\n          ivec4 emissiveSpecularGlossinessMapIndex[NUM_MATERIALS];\n      #endif\n      #if defined(NUM_DIFFUSE_MAPS) || defined(NUM_NORMAL_MAPS)\n          vec4 diffuseNormalMapSize[NUM_DIFFUSE_NORMAL_MAPS];\n      #endif\n      #if defined(NUM_PBR_MAPS)\n          vec2 pbrMapSize[NUM_PBR_MAPS];\n      #else\n      #if defined(NUM_PBR_SG_MAPS)\n          vec2 pbrMapSize[NUM_PBR_SG_MAPS];\n      #else\n      #if defined(NUM_EMISSIVE_MAPS)\n          vec2 pbrMapSize[NUM_EMISSIVE_MAPS];\n      #endif\n      #endif\n      #endif\n      } materials;\n      #ifdef NUM_DIFFUSE_MAPS\n      uniform mediump sampler2DArray diffuseMap;\n      #endif\n      #ifdef NUM_NORMAL_MAPS\n      uniform mediump sampler2DArray normalMap;\n      #endif\n      #ifdef NUM_PBR_MAPS\n      uniform mediump sampler2DArray pbrMap;\n      #endif\n      #ifdef NUM_PBR_SG_MAPS\n      uniform mediump sampler2DArray pbrSGMap;\n      #endif\n      #ifdef NUM_EMISSIVE_MAPS\n      uniform mediump sampler2DArray emissiveMap;\n      #endif\n      float LGL_p(int materialIndex) {\n          return materials.colorAndMaterialType[materialIndex].w;\n      }\n      float LGL_q(int materialIndex) {\n          return materials.iorAtDistanceAnisotropicWorkflow[materialIndex].w;\n      }\n      vec3 LGL_r(int materialIndex, vec2 uv) {\n          vec3 emissive = vec3(0.0);\n      #ifdef NUM_EMISSIVE_MAPS\n          int emissiveMapIndex = materials.emissiveSpecularGlossinessMapIndex[materialIndex].x;\n          if(emissiveMapIndex >= 0) {\n              emissive = texture(emissiveMap, vec3(uv * materials.pbrMapSize[emissiveMapIndex].xy, emissiveMapIndex)).rgb;\n          }\n      #endif\n          return emissive;\n      }\n      vec3 LGL_s(int materialIndex, vec2 uv) {\n          vec3 specularColor = materials.specularColorGlossiness[materialIndex].rgb;\n      #ifdef NUM_PBR_SG_MAPS\n          int specularMapIndex = materials.emissiveSpecularGlossinessMapIndex[materialIndex].y;\n          if(specularMapIndex >= 0) {\n              vec3 texelSpecular = texture(pbrSGMap, vec3(uv * materials.pbrMapSize[specularMapIndex].xy, specularMapIndex)).rgb;\n              texelSpecular = pow(texelSpecular, vec3(2.2));\n              specularColor *= texelSpecular;\n          }\n      #endif\n          return specularColor;\n      }\n      float LGL_t(int materialIndex, vec2 uv) {\n          float glossiness = materials.specularColorGlossiness[materialIndex].a;\n      #ifdef NUM_PBR_SG_MAPS\n          int glossinessMapIndex = materials.emissiveSpecularGlossinessMapIndex[materialIndex].z;\n          if(glossinessMapIndex >= 0) {\n              float texelGlossiness = texture(pbrSGMap, vec3(uv * materials.pbrMapSize[glossinessMapIndex].xy, glossinessMapIndex)).a;\n              glossiness *= texelGlossiness;\n          }\n      #endif\n          return glossiness;\n      }\n      float LGL_u(int materialIndex, vec2 uv) {\n          float LGL_BG = LGL_q(materialIndex);\n          float roughness = 0.0;\n          if(LGL_BG > 0.1) {\n              roughness = 1.0 - LGL_t(materialIndex, uv);\n          } else {\n              roughness = materials.roughnessMetalnessNormalScale[materialIndex].x;\n      #ifdef NUM_PBR_MAPS\n              int roughnessMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialIndex].z;\n              if(roughnessMapIndex >= 0) {\n                  roughness *= texture(pbrMap, vec3(uv * materials.pbrMapSize[roughnessMapIndex].xy, roughnessMapIndex)).g;\n              }\n      #endif\n          }\n          return roughness * roughness;\n      }\n      float LGL_v(const vec3 v) {\n          return max(v.x, max(v.y, v.z));\n      }\n      float LGL_w(const vec3 specularColor) {\n          return LGL_v(specularColor);\n      }\n      vec3 LGL_x(const vec3 baseColor, float metallic) {\n          return baseColor * (1.0 - metallic);\n      }\n      float LGL_y(int materialIndex, vec2 uv) {\n          float LGL_BG = LGL_q(materialIndex);\n          float metalness = 0.0;\n          if(LGL_BG > 0.1) {\n              vec3 specularFactor = LGL_s(materialIndex, uv);\n              metalness = LGL_w(specularFactor);\n          } else {\n              metalness = materials.roughnessMetalnessNormalScale[materialIndex].y;\n      #ifdef NUM_PBR_MAPS\n              int metalnessMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialIndex].w;\n              if(metalnessMapIndex >= 0) {\n                  metalness *= texture(pbrMap, vec3(uv * materials.pbrMapSize[metalnessMapIndex].xy, metalnessMapIndex)).b;\n              }\n      #endif\n          }\n          return metalness;\n      }\n      vec3 LGL_z(int materialIndex, vec2 uv) {\n          vec3 color = materials.colorAndMaterialType[materialIndex].rgb;\n      #ifdef NUM_DIFFUSE_MAPS\n          int diffuseMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialIndex].x;\n          if(diffuseMapIndex >= 0) {\n              color *= texture(diffuseMap, vec3(uv * materials.diffuseNormalMapSize[diffuseMapIndex].xy, diffuseMapIndex)).rgb;\n          }\n      #endif\n          float LGL_BG = LGL_q(materialIndex);\n          if(LGL_BG > 0.1) {\n              vec3 specularFactor = LGL_s(materialIndex, uv);\n              color = LGL_x(color, LGL_w(specularFactor));\n          }\n          return color;\n      }\n      vec3 LGL_AA(int materialIndex, vec2 uv, vec3 normal, vec3 dp1, vec3 dp2, vec2 duv1, vec2 duv2, inout vec3 tangent, inout vec3 bitangent) {\n          vec3 dp2perp = cross(dp2, normal);\n          vec3 dp1perp = cross(normal, dp1);\n          vec3 dpdu = dp2perp * duv1.x + dp1perp * duv2.x;\n          vec3 dpdv = dp2perp * duv1.y + dp1perp * duv2.y;\n          float invmax = inversesqrt(max(dot(dpdu, dpdu), dot(dpdv, dpdv)));\n          dpdu *= invmax;\n          dpdv *= invmax;\n          tangent = normalize(dpdu);\n          bitangent = normalize(dpdv);\n      #ifdef NUM_NORMAL_MAPS\n          int normalMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialIndex].y;\n          if(normalMapIndex >= 0) {\n              vec3 n = 2.0 * texture(normalMap, vec3(uv * materials.diffuseNormalMapSize[normalMapIndex].zw, normalMapIndex)).rgb - 1.0;\n              n.xy *= materials.roughnessMetalnessNormalScale[materialIndex].zw;\n              mat3 tbn = mat3(dpdu, dpdv, normal);\n              return normalize(tbn * n);\n          } else {\n              return normal;\n          }\n      #endif\n          return normal;\n      }\n      float LGL_AD(int materialIndex, vec2 uv) {\n          float alpha = materials.alphaSpecularTintSheenSheenTint[materialIndex].x;\n      #ifdef NUM_DIFFUSE_MAPS\n          int diffuseMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialIndex].x;\n          if(diffuseMapIndex >= 0) {\n              alpha *= texture(diffuseMap, vec3(uv * materials.diffuseNormalMapSize[diffuseMapIndex].xy, diffuseMapIndex)).a;\n          }\n      #endif\n          return alpha;\n      }\n      float LGL_AB(int materialIndex) {\n          return materials.alphaSpecularTintSheenSheenTint[materialIndex].y;\n      }\n      float LGL_AC(int materialIndex) {\n          return materials.alphaSpecularTintSheenSheenTint[materialIndex].z;\n      }\n      float LGL_ACTint(int materialIndex) {\n          return materials.alphaSpecularTintSheenSheenTint[materialIndex].w;\n      }\n      float LGL_AF(int materialIndex) {\n          return materials.clearcoaRoughnessSubfaceTransmission[materialIndex].x;\n      }\n      float LGL_AFRoughness(int materialIndex) {\n          return materials.clearcoaRoughnessSubfaceTransmission[materialIndex].y;\n      }\n      float LGL_AH(int materialIndex) {\n          return materials.clearcoaRoughnessSubfaceTransmission[materialIndex].z;\n      }\n      float LGL_AI(int materialIndex) {\n          return materials.clearcoaRoughnessSubfaceTransmission[materialIndex].w;\n      }\n      float LGL_AJ(int materialIndex) {\n          return materials.iorAtDistanceAnisotropicWorkflow[materialIndex].x;\n      }\n      float LGL_AK(int materialIndex) {\n          return materials.iorAtDistanceAnisotropicWorkflow[materialIndex].y;\n      }\n      float LGL_AL(int materialIndex) {\n          return materials.iorAtDistanceAnisotropicWorkflow[materialIndex].z;\n      }\n      vec3 LGL_AM(int materialIndex) {\n          return materials.extinction[materialIndex].rgb;\n      }\n      uniform sampler2D positionBuffer;\n      uniform sampler2D normalBuffer;\n      uniform sampler2D uvBuffer;\n      uniform sampler2D bvhBuffer;\n      struct Triangle {\n          vec3 p0;\n          vec3 p1;\n          vec3 p2;\n      };\n      struct Box {\n          vec3 min;\n          vec3 max;\n      };\n      struct TriangleIntersect {\n          float t;\n          vec3 barycentric;\n      };\n      float LGL_f(float rad, vec3 pos, Ray r) {\n          vec3 op = pos - r.o;\n          float eps = 0.001;\n          float b = dot(op, r.d);\n          float det = b * b - dot(op, op) + rad * rad;\n          if(det < 0.0)\n              return INF;\n          det = sqrt(det);\n          float t1 = b - det;\n          if(t1 > eps)\n              return t1;\n          float t2 = b + det;\n          if(t2 > eps)\n              return t2;\n          return INF;\n      }\n      float LGL_g(in vec3 pos, in vec3 u, in vec3 v, in vec4 plane, in Ray r) {\n          vec3 n = vec3(plane);\n          float dt = dot(r.d, n);\n          float t = (plane.w - dot(n, r.o)) / dt;\n          if(t > EPS) {\n              vec3 p = r.o + r.d * t;\n              vec3 vi = p - pos;\n              float a1 = dot(u, vi);\n              if(a1 >= 0. && a1 <= 1.) {\n                  float a2 = dot(v, vi);\n                  if(a2 >= 0. && a2 <= 1.)\n                      return t;\n              }\n          }\n          return INF;\n      }\n      float LGL_h(vec3 v0, vec3 v1, vec3 v2, Ray r, bool isDoubleSided) {\n          vec3 edge1 = v1 - v0;\n          vec3 edge2 = v2 - v0;\n          vec3 pvec = cross(r.d, edge2);\n          float det = 1.0 / dot(edge1, pvec);\n          if(!isDoubleSided && det < 0.0)\n              return INF;\n          vec3 tvec = r.o - v0;\n          float u = dot(tvec, pvec) * det;\n          vec3 qvec = cross(tvec, edge1);\n          float v = dot(r.d, qvec) * det;\n          float t = dot(edge2, qvec) * det;\n          return (u < 0.0 || u > 1.0 || v < 0.0 || u + v > 1.0 || t <= 0.0) ? INF : t;\n      }\n      float LGL_gClassic(vec3 v1, vec3 v2, vec3 v3, vec3 v4, Ray r, bool isDoubleSided) {\n          return min(LGL_h(v1, v3, v2, r, isDoubleSided), LGL_h(v2, v3, v4, r, isDoubleSided));\n      }\n      void LGL_j(inout SurfaceInteraction si, Triangle tri, vec3 barycentric, ivec3 index, vec3 LGL_BM, int materialIndex) {\n          si.LGL_BK = true;\n          si.LGL_BM = LGL_BM;\n          si.position = barycentric.x * tri.p0 + barycentric.y * tri.p1 + barycentric.z * tri.p2;\n          ivec2 i0 = LGL_AX(index.x, VERTEX_COLUMNS);\n          ivec2 i1 = LGL_AX(index.y, VERTEX_COLUMNS);\n          ivec2 i2 = LGL_AX(index.z, VERTEX_COLUMNS);\n          vec3 n0 = texelFetch(normalBuffer, i0, 0).xyz;\n          vec3 n1 = texelFetch(normalBuffer, i1, 0).xyz;\n          vec3 n2 = texelFetch(normalBuffer, i2, 0).xyz;\n          vec3 normal = normalize(barycentric.x * n0 + barycentric.y * n1 + barycentric.z * n2);\n          vec2 uv0 = texelFetch(uvBuffer, i0, 0).xy;\n          vec2 uv1 = texelFetch(uvBuffer, i1, 0).xy;\n          vec2 uv2 = texelFetch(uvBuffer, i2, 0).xy;\n      #if defined(NUM_DIFFUSE_MAPS) || defined(NUM_NORMAL_MAPS) || defined(NUM_PBR_MAPS)\n          vec2 uv = fract(barycentric.x * uv0 + barycentric.y * uv1 + barycentric.z * uv2);\n      #else\n          vec2 uv = vec2(0.0);\n      #endif\n          si.LGL_BH = int(LGL_p(materialIndex));\n          si.color = LGL_z(materialIndex, uv);\n          si.roughness = LGL_u(materialIndex, uv);\n          si.metalness = LGL_y(materialIndex, uv);\n          si.specularColor = LGL_s(materialIndex, uv);\n          si.LGL_BG = LGL_q(materialIndex);\n          si.emissive = LGL_r(materialIndex, uv);\n          vec3 dp1 = tri.p0 - tri.p2;\n          vec3 dp2 = tri.p1 - tri.p2;\n          vec2 duv1 = uv0 - uv2;\n          vec2 duv2 = uv1 - uv2;\n          si.normal = LGL_AA(materialIndex, uv, normal, dp1, dp2, duv1, duv2, si.tangent, si.bitangent);\n          si.LGL_Ay = LGL_AB(materialIndex);\n          si.sheen = LGL_AC(materialIndex);\n          si.LGL_Az = LGL_ACTint(materialIndex);\n          si.clearcoat = LGL_AF(materialIndex);\n          si.LGL_BA = LGL_AFRoughness(materialIndex);\n          si.LGL_BB = LGL_AH(materialIndex);\n          si.LGL_BC = LGL_AI(materialIndex);\n          si.LGL_BD = LGL_AD(materialIndex, uv);\n          si.ior = LGL_AJ(materialIndex);\n          si.LGL_BE = LGL_AK(materialIndex);\n          si.LGL_BF = LGL_AL(materialIndex);\n          si.extinction = LGL_AM(materialIndex);\n      }\n      TriangleIntersect LGL_k(Ray r, Triangle tri) {\n          vec3 v0 = tri.p0;\n          vec3 v1 = tri.p1;\n          vec3 v2 = tri.p2;\n          TriangleIntersect ti;\n          vec3 e0 = v1 - v0;\n          vec3 e1 = v2 - v0;\n          vec3 pv = cross(r.d, e1);\n          float det = dot(e0, pv);\n          vec3 tv = r.o - v0;\n          vec3 qv = cross(tv, e0);\n          vec4 uvt;\n          uvt.x = dot(tv, pv);\n          uvt.y = dot(r.d, qv);\n          uvt.z = dot(e1, qv);\n          uvt.xyz = uvt.xyz / det;\n          uvt.w = 1.0 - uvt.x - uvt.y;\n          if(uvt.z >= r.LGL_BO) {\n              return ti;\n          }\n          if(all(greaterThanEqual(uvt, vec4(0.0))) && uvt.z < INF) {\n              ti.t = uvt.z;\n              ti.barycentric = uvt.wxy;\n          }\n          return ti;\n      }\n      float LGL_l(Ray r, Box b) {\n          vec3 tBot = (b.min - r.o) * r.LGL_BN;\n          vec3 tTop = (b.max - r.o) * r.LGL_BN;\n          vec3 tNear = min(tBot, tTop);\n          vec3 tFar = max(tBot, tTop);\n          float t0 = max(tNear.x, max(tNear.y, tNear.z));\n          float t1 = min(tFar.x, min(tFar.y, tFar.z));\n          return (t0 > t1 || t0 > r.LGL_BO) ? -1.0 : (t0 > 0.0 ? t0 : t1);\n      }\n      bool LGL_m(inout Ray ray, float maxDist) {\n      #if defined(NUM_LIGHTS)\n          for(int i = 0; i < NUM_LIGHTS; i++) {\n              vec3 position = lights.position[i];\n              vec3 emission = lights.emission[i];\n              vec3 p1 = lights.p1[i];\n              vec3 p2 = lights.p2[i];\n              vec4 params = lights.params[i];\n              float radius = params.x;\n              float area = params.y;\n              float type = params.z;\n              float visible = params.w;\n              if(type == 0. || type == 1.) {\n                  vec3 normal = normalize(cross(p1, p2));\n                  if(dot(normal, ray.d) > 0.)\n                      continue;\n                  vec4 plane = vec4(normal, dot(normal, position));\n                  p1 *= 1.0 / dot(p1, p1);\n                  p2 *= 1.0 / dot(p2, p2);\n                  float d = LGL_g(position, p1, p2, plane, ray);\n                  if(d > 0. && d < maxDist)\n                      return true;\n              }\n              if(type == 1.) {\n                  float d = LGL_f(radius, position, ray);\n                  if(d > 0. && d < maxDist)\n                      return true;\n              }\n          }\n      #endif\n          int nodesToVisit[STACK_SIZE];\n          nodesToVisit[0] = 0;\n          int stack = 0;\n          while(stack >= 0) {\n              int i = nodesToVisit[stack--];\n              vec4 r1 = LGL_AY(bvhBuffer, i, BVH_COLUMNS);\n              vec4 r2 = LGL_AY(bvhBuffer, i + 1, BVH_COLUMNS);\n              int splitAxisOrNumPrimitives = floatBitsToInt(r1.w);\n              if(splitAxisOrNumPrimitives >= 0) {\n                  int splitAxis = splitAxisOrNumPrimitives;\n                  Box bbox = Box(r1.xyz, r2.xyz);\n                  if(LGL_l(ray, bbox) > 0.0) {\n                      if(ray.d[splitAxis] > 0.0) {\n                          nodesToVisit[++stack] = floatBitsToInt(r2.w);\n                          nodesToVisit[++stack] = i + 2;\n                      } else {\n                          nodesToVisit[++stack] = i + 2;\n                          nodesToVisit[++stack] = floatBitsToInt(r2.w);\n                      }\n                  }\n              } else {\n                  ivec3 index = floatBitsToInt(r1.xyz);\n                  Triangle tri = Triangle(LGL_AY(positionBuffer, index.x, VERTEX_COLUMNS).xyz, LGL_AY(positionBuffer, index.y, VERTEX_COLUMNS).xyz, LGL_AY(positionBuffer, index.z, VERTEX_COLUMNS).xyz);\n                  TriangleIntersect LGL_BK = LGL_k(ray, tri);\n                  if(LGL_BK.t > 0.0 && LGL_BK.t < maxDist) {\n                      return true;\n                  }\n              }\n          }\n          return false;\n      }\n      void LGL_n(inout Ray ray, inout SurfaceInteraction si, inout LightSampleRec lightSampleRec, int bounce) {\n          si.LGL_BK = false;\n          float t = INF;\n          float d;\n      #if defined(NUM_LIGHTS)\n          for(int i = 0; i < NUM_LIGHTS; i++) {\n              vec4 params = lights.params[i];\n              float radius = params.x;\n              float area = params.y;\n              float type = params.z;\n              float visible = params.w;\n              if(bounce == 0 && visible < 0.1)\n                  continue;\n              vec3 position = lights.position[i];\n              vec3 emission = lights.emission[i];\n              vec3 p1 = lights.p1[i];\n              vec3 p2 = lights.p2[i];\n              if(type == 0. || type == 1.) {\n                  vec3 normal = normalize(cross(p1, p2));\n                  if(dot(normal, ray.d) > 0.)\n                      continue;\n                  vec4 plane = vec4(normal, dot(normal, position));\n                  p1 *= 1.0 / dot(p1, p1);\n                  p2 *= 1.0 / dot(p2, p2);\n                  d = LGL_g(position, p1, p2, plane, ray);\n                  if(d < 0.)\n                      d = INF;\n                  if(d < t) {\n                      t = d;\n                      float cosTheta = dot(-ray.d, normal);\n                      float pdf = (t * t) / (area * cosTheta);\n                      lightSampleRec.emission = emission;\n                      lightSampleRec.pdf = pdf;\n                      si.LGL_BK = true;\n                      si.LGL_BI = true;\n                      ray.LGL_BO = t;\n                  }\n              }\n              if(type == 2.) {\n                  d = LGL_f(radius, position, ray);\n                  if(d < 0.)\n                      d = INF;\n                  if(d < t) {\n                      t = d;\n                      float pdf = (t * t) / area;\n                      lightSampleRec.emission = emission;\n                      lightSampleRec.pdf = pdf;\n                      si.LGL_BK = true;\n                      si.LGL_BI = true;\n                      ray.LGL_BO = t;\n                  }\n              }\n          }\n      #endif\n          int nodesToVisit[STACK_SIZE];\n          nodesToVisit[0] = 0;\n          int stack = 0;\n          while(stack >= 0) {\n              int i = nodesToVisit[stack--];\n              vec4 r1 = LGL_AY(bvhBuffer, i, BVH_COLUMNS);\n              vec4 r2 = LGL_AY(bvhBuffer, i + 1, BVH_COLUMNS);\n              int splitAxisOrNumPrimitives = floatBitsToInt(r1.w);\n              if(splitAxisOrNumPrimitives >= 0) {\n                  int splitAxis = splitAxisOrNumPrimitives;\n                  Box bbox = Box(r1.xyz, r2.xyz);\n                  if(LGL_l(ray, bbox) > 0.0) {\n                      if(ray.d[splitAxis] > 0.0) {\n                          nodesToVisit[++stack] = floatBitsToInt(r2.w);\n                          nodesToVisit[++stack] = i + 2;\n                      } else {\n                          nodesToVisit[++stack] = i + 2;\n                          nodesToVisit[++stack] = floatBitsToInt(r2.w);\n                      }\n                  }\n              } else {\n                  ivec3 index = floatBitsToInt(r1.xyz);\n                  Triangle tri = Triangle(LGL_AY(positionBuffer, index.x, VERTEX_COLUMNS).xyz, LGL_AY(positionBuffer, index.y, VERTEX_COLUMNS).xyz, LGL_AY(positionBuffer, index.z, VERTEX_COLUMNS).xyz);\n                  TriangleIntersect LGL_BK = LGL_k(ray, tri);\n                  if(LGL_BK.t > 0.0) {\n                      int materialIndex = floatBitsToInt(r2.w);\n                      vec3 LGL_BM = r2.xyz;\n                      si.t = LGL_BK.t;\n                      si.LGL_BI = false;\n                      ray.LGL_BO = LGL_BK.t;\n                      LGL_j(si, tri, LGL_BK.barycentric, index, LGL_BM, materialIndex);\n                      si.LGL_BL = dot(si.LGL_BM, ray.d) <= 0.0 ? si.normal : -si.normal;\n                  }\n              }\n          }\n          si.roughness = clamp(si.roughness, ROUGHNESS_MIN, 1.0);\n          si.metalness = clamp(si.metalness, 0.0, 1.0);\n      }\n      void LGL_o(inout Ray ray, inout SurfaceInteraction si, inout LightSampleRec lightSampleRec, int depth) {\n          if(si.LGL_BK && !si.LGL_BI && si.LGL_BD < 1.0) {\n              float LGL_BJ = LGL_AQ();\n              while(si.LGL_BK && !si.LGL_BI && LGL_BJ > si.LGL_BD) {\n                  LGL_AW(ray, si.position + EPS * ray.d, ray.d);\n                  LGL_n(ray, si, lightSampleRec, depth);\n              }\n          }\n      }\n      #ifndef CONST_COLOR_ENV\n      uniform sampler2D envMap;\n      uniform sampler2D envMapDistribution;\n      vec2 LGL_Y(vec3 pointOnSphere) {\n          float phi = mod(atan(-pointOnSphere.z, -pointOnSphere.x), TWOPI);\n          float theta = acos(pointOnSphere.y);\n          return vec2(phi * 0.5 * INVPI, theta * INVPI);\n      }\n      vec3 LGL_Z(vec3 d) {\n          vec2 uv = LGL_Y(d);\n          return LGL_An(envMap, uv).rgb;\n      }\n      float LGL_a(float u, out int vOffset, out float pdf) {\n          ivec2 size = textureSize(envMap, 0);\n          int left = 0;\n          int right = size.y + 1;\n          while(left < right) {\n              int mid = (left + right) >> 1;\n              float s = texelFetch(envMapDistribution, ivec2(0, mid), 0).x;\n              if(s <= u) {\n                  left = mid + 1;\n              } else {\n                  right = mid;\n              }\n          }\n          vOffset = left - 1;\n          vec2 s0 = texelFetch(envMapDistribution, ivec2(0, vOffset), 0).xy;\n          vec2 s1 = texelFetch(envMapDistribution, ivec2(0, vOffset + 1), 0).xy;\n          pdf = s0.y;\n          return (float(vOffset) + (u - s0.x) / (s1.x - s0.x)) / float(size.y);\n      }\n      float LGL_b(float u, int vOffset, out float pdf) {\n          ivec2 size = textureSize(envMap, 0);\n          int left = 0;\n          int right = size.x + 1;\n          while(left < right) {\n              int mid = (left + right) >> 1;\n              float s = texelFetch(envMapDistribution, ivec2(1 + mid, vOffset), 0).x;\n              if(s <= u) {\n                  left = mid + 1;\n              } else {\n                  right = mid;\n              }\n          }\n          int uOffset = left - 1;\n          vec2 s0 = texelFetch(envMapDistribution, ivec2(1 + uOffset, vOffset), 0).xy;\n          vec2 s1 = texelFetch(envMapDistribution, ivec2(1 + uOffset + 1, vOffset), 0).xy;\n          pdf = s0.y;\n          return (float(uOffset) + (u - s0.x) / (s1.x - s0.x)) / float(size.x);\n      }\n      float LGL_c(vec2 uv) {\n          vec2 size = vec2(textureSize(envMap, 0));\n          float sinTheta = sin(uv.y * PI);\n          uv *= size;\n          float partialX = texelFetch(envMapDistribution, ivec2(1.0 + uv.x, uv.y), 0).y;\n          float partialY = texelFetch(envMapDistribution, ivec2(0, uv.y), 0).y;\n          return partialX * partialY * INVPI2 / (2.0 * sinTheta);\n      }\n      vec3 LGL_d(vec2 LGL_AQom, out vec2 uv, out float pdf) {\n          vec2 partialPdf;\n          int vOffset;\n          uv.y = LGL_a(LGL_AQom.x, vOffset, partialPdf.y);\n          uv.x = LGL_b(LGL_AQom.y, vOffset, partialPdf.x);\n          float phi = uv.x * TWOPI;\n          float theta = uv.y * PI;\n          float cosTheta = cos(theta);\n          float sinTheta = sin(theta);\n          float cosPhi = cos(phi);\n          float sinPhi = sin(phi);\n          vec3 dir = vec3(-sinTheta * cosPhi, cosTheta, -sinTheta * sinPhi);\n          pdf = partialPdf.x * partialPdf.y * INVPI2 / (2.0 * sinTheta);\n          return dir;\n      }\n      #endif\n      void LGL_AZ(in vec3 N, inout vec3 T, inout vec3 B) {\n          if(N.z < -0.999999) {\n              T = vec3(0., -1., 0.);\n              B = vec3(-1., 0., 0.);\n          } else {\n              float a = 1.0 / (1. + N.z);\n              float b = -N.x * N.y * a;\n              T = vec3(1.0 - N.x * N.x * a, b, -N.x);\n              B = vec3(b, 1. - N.y * N.y * a, -N.y);\n          }\n      }\n      vec3 LGL_Am(vec3 V, float rgh, float r1, float r2) {\n          vec3 Vh = normalize(vec3(rgh * V.x, rgh * V.y, V.z));\n          float lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n          vec3 T1 = lensq > 0. ? vec3(-Vh.y, Vh.x, 0) * inversesqrt(lensq) : vec3(1., 0., 0.);\n          vec3 T2 = cross(Vh, T1);\n          float r = sqrt(r1);\n          float phi = 2.0 * PI * r2;\n          float t1 = r * cos(phi);\n          float t2 = r * sin(phi);\n          float s = 0.5 * (1.0 + Vh.z);\n          t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;\n          vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;\n          return normalize(vec3(rgh * Nh.x, rgh * Nh.y, max(0.0, Nh.z)));\n      }\n      vec2 LGL_Aa(vec2 p) {\n          p = 2.0 * p - 1.0;\n          bool greater = abs(p.x) > abs(p.y);\n          float r = greater ? p.x : p.y;\n          float theta = greater ? 0.25 * PI * p.y / p.x : PI * (0.5 - 0.25 * p.x / p.y);\n          return r * vec2(cos(theta), sin(theta));\n      }\n      vec3 LGL_Ab(vec2 p) {\n          vec2 h = LGL_Aa(p);\n          float z = sqrt(max(0.0, 1.0 - h.x * h.x - h.y * h.y));\n          return vec3(h, z);\n      }\n      vec3 LGL_Ac(float r1, float r2) {\n          float z = 1.0 - 2.0 * r1;\n          float r = sqrt(max(0.0, 1.0 - z * z));\n          float phi = TWOPI * r2;\n          return vec3(r * cos(phi), r * sin(phi), z);\n      }\n      vec3 LGL_Ad(vec3 LGL_BM, vec3 viewDir, mat3 basis, float roughness, vec2 LGL_AQom) {\n          float phi = TWOPI * LGL_AQom.y;\n          float alpha = roughness * roughness;\n          float cosTheta = sqrt((1.0 - LGL_AQom.x) / (1.0 + (alpha * alpha - 1.0) * LGL_AQom.x));\n          float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n          vec3 halfVector = basis * sign(dot(LGL_BM, viewDir)) * vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n          vec3 lightDir = reflect(-viewDir, halfVector);\n          return lightDir;\n      }\n      vec3 LGL_Ae(vec3 LGL_BM, vec3 viewDir, mat3 basis, vec2 LGL_AQom) {\n          return basis * sign(dot(LGL_BM, viewDir)) * LGL_Ab(LGL_AQom);\n      }\n      float LGL_Af(float f, float g) {\n          return (f * f) / (f * f + g * g);\n      }\n      vec3 LGL_Ag(in Ray r, int depth, in LightSampleRec lightSampleRec, in BsdfSampleRec bsdfSampleRec) {\n          vec3 Le;\n          if(depth == 0) {\n              Le = lightSampleRec.emission;\n          } else {\n              Le = LGL_Af(bsdfSampleRec.pdf, lightSampleRec.pdf) * lightSampleRec.emission;\n          }\n          return Le;\n      }\n      #if defined(NUM_LIGHTS)\n      void LGL_Ah(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec, vec2 LGL_AQom) {\n          float r1 = LGL_AQom.x;\n          float r2 = LGL_AQom.y;\n          vec3 lightSurfacePos = light.position + LGL_Ac(r1, r2) * light.radius;\n          lightSampleRec.direction = lightSurfacePos - surfacePos;\n          lightSampleRec.dist = length(lightSampleRec.direction);\n          float distSq = lightSampleRec.dist * lightSampleRec.dist;\n          lightSampleRec.direction /= lightSampleRec.dist;\n          lightSampleRec.normal = normalize(lightSurfacePos - light.position);\n          lightSampleRec.emission = light.emission * float(NUM_LIGHTS);\n          lightSampleRec.pdf = distSq / (light.area * abs(dot(lightSampleRec.normal, lightSampleRec.direction)));\n      }\n      void LGL_Aj(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec, vec2 LGL_AQom) {\n          float r1 = LGL_AQom.x;\n          float r2 = LGL_AQom.y;\n          vec3 lightSurfacePos = light.position + light.p1 * r1 + light.p2 * r2;\n          lightSampleRec.direction = lightSurfacePos - surfacePos;\n          lightSampleRec.dist = length(lightSampleRec.direction);\n          float distSq = lightSampleRec.dist * lightSampleRec.dist;\n          lightSampleRec.direction /= lightSampleRec.dist;\n          lightSampleRec.normal = normalize(cross(light.p1, light.p2));\n          lightSampleRec.emission = light.emission * float(NUM_LIGHTS);\n          lightSampleRec.pdf = distSq / (light.area * abs(dot(lightSampleRec.normal, lightSampleRec.direction)));\n      }\n      void LGL_Ak(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec) {\n          lightSampleRec.direction = normalize(light.position - light.p1);\n          lightSampleRec.normal = normalize(surfacePos - light.position);\n          if(dot(lightSampleRec.direction, lightSampleRec.normal) > 0.0) {\n              lightSampleRec.normal = -lightSampleRec.normal;\n          }\n          lightSampleRec.emission = light.emission * float(NUM_LIGHTS);\n          lightSampleRec.dist = INF;\n          lightSampleRec.pdf = 1.0;\n      }\n      void samplePointLight(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec) {\n          lightSampleRec.direction = light.position - surfacePos;\n          lightSampleRec.dist = length(lightSampleRec.direction);\n          float distSq = lightSampleRec.dist * lightSampleRec.dist;\n          lightSampleRec.direction = normalize(lightSampleRec.direction);\n          lightSampleRec.normal = normalize(surfacePos - light.position);\n          lightSampleRec.emission = light.emission * float(NUM_LIGHTS) / distSq;\n          lightSampleRec.pdf = 1.0;\n      }\n      void LGL_Al(in Light light, in vec3 surfacePos, inout LightSampleRec lightSampleRec, vec2 LGL_AQom) {\n          int type = int(light.type);\n          if(type == 0 || type == 1) {\n              LGL_Aj(light, surfacePos, lightSampleRec, LGL_AQom);\n          } else if(type == 2) {\n              LGL_Ah(light, surfacePos, lightSampleRec, LGL_AQom);\n          } else if(type == 3) {\n              LGL_Ak(light, surfacePos, lightSampleRec);\n          } else if(type == 4) {\n              samplePointLight(light, surfacePos, lightSampleRec);\n          }\n      }\n      #endif\n      vec3 LocalToWorld(vec3 X, vec3 Y, vec3 Z, vec3 V) {\n          return vec3(X.x * V.x + Y.x * V.y + Z.x * V.z, X.y * V.x + Y.y * V.y + Z.y * V.z, X.z * V.x + Y.z * V.y + Z.z * V.z);\n      }\n      vec3 WorldToLocal(vec3 X, vec3 Y, vec3 Z, vec3 V) {\n          return vec3(dot(V, X), dot(V, Y), dot(V, Z));\n      }\n      vec3 LGL_A(float r1, float r2) {\n          vec3 dir;\n          float r = sqrt(r1);\n          float phi = TWOPI * r2;\n          dir.x = r * cos(phi);\n          dir.y = r * sin(phi);\n          dir.z = sqrt(max(0.0, 1.0 - dir.x * dir.x - dir.y * dir.y));\n          return dir;\n      }\n      float LGL_B(float eta) {\n          float sqrtR0 = (eta - 1.) / (eta + 1.);\n          return sqrtR0 * sqrtR0;\n      }\n      vec3 LGL_C(vec3 baseColor) {\n          float luminance = LGL_AV(baseColor);\n          return (luminance > 0.0) ? baseColor / luminance : vec3(1.);\n      }\n      void LGL_D(SurfaceInteraction si, out vec3 Cspec0, out vec3 Csheen) {\n          vec3 tint = LGL_C(si.color);\n          if(si.LGL_BG > 0.1) {\n              Cspec0 = si.specularColor;\n          } else {\n              Cspec0 = mix(LGL_B(si.ior) * mix(vec3(1.0), tint, min(si.LGL_Ay, 0.99)), si.color, si.metalness);\n          }\n          Csheen = mix(vec3(1.0), tint, si.LGL_Az);\n      }\n      float LGL_E(float u) {\n          float m = clamp(1.0 - u, 0.0, 1.0);\n          float m2 = m * m;\n          return m2 * m2 * m;\n      }\n      float LGL_F(float F0, float cosTheta) {\n          return mix(F0, 1.0, LGL_E(cosTheta));\n      }\n      vec3 LGL_F(vec3 F0, float cosTheta) {\n          return mix(F0, vec3(1.), LGL_E(cosTheta));\n      }\n      float LGL_G(float cosThetaI, float eta) {\n          float sinThetaTSq = eta * eta * (1.0f - cosThetaI * cosThetaI);\n          if(sinThetaTSq > 1.0)\n              return 1.0;\n          float cosThetaT = sqrt(max(1.0 - sinThetaTSq, 0.0));\n          float rs = (eta * cosThetaT - cosThetaI) / (eta * cosThetaT + cosThetaI);\n          float rp = (eta * cosThetaI - cosThetaT) / (eta * cosThetaI + cosThetaT);\n          return 0.5 * (rs * rs + rp * rp);\n      }\n      vec3 LGL_H(vec3 F0, float metalness, float eta, float cosThetaI) {\n          vec3 FrSchlick = LGL_F(F0, cosThetaI);\n          float FrDielectric = LGL_G(cosThetaI, eta);\n          return mix(vec3(FrDielectric), FrSchlick, metalness);\n      }\n      float LGL_H(float metalness, float eta, float cosThetaI) {\n          float FrSchlick = LGL_E(cosThetaI);\n          float FrDielectric = LGL_G(cosThetaI, eta);\n          return mix(FrDielectric, FrSchlick, metalness);\n      }\n      float LGL_I(float NDotV, float alphaG) {\n          float a = alphaG * alphaG;\n          float b = NDotV * NDotV;\n          return 1.0 / (NDotV + sqrt(a + b - a * b));\n      }\n      float LGL_J(float NDotH, float alpha) {\n          float alpha2 = alpha * alpha;\n          float t = 1.0 + (alpha2 - 1.0) * NDotH * NDotH;\n          return (alpha2 - 1.0) / (PI * log(alpha2) * t);\n      }\n      float LGL_K(float NDotH, float a) {\n          float a2 = a * a;\n          float t = 1.0 + (a2 - 1.0) * NDotH * NDotH;\n          return a2 / (PI * t * t);\n      }\n      vec3 ImportanceSampleLGL_J(float rgh, float r1, float r2) {\n          float a = max(0.001, rgh);\n          float a2 = a * a;\n          float phi = r1 * TWOPI;\n          float cosTheta = sqrt((1.0 - pow(a2, 1.0 - r1)) / (1.0 - a2));\n          float sinTheta = clamp(sqrt(1.0 - (cosTheta * cosTheta)), 0.0, 1.0);\n          float sinPhi = sin(phi);\n          float cosPhi = cos(phi);\n          return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);\n      }\n      vec3 ImportanceSampleLGL_K(float rgh, float r1, float r2) {\n          float a = max(0.001, rgh);\n          float phi = r1 * TWOPI;\n          float cosTheta = sqrt((1.0 - r2) / (1.0 + (a * a - 1.0) * r2));\n          float sinTheta = clamp(sqrt(1.0 - (cosTheta * cosTheta)), 0.0, 1.0);\n          float sinPhi = sin(phi);\n          float cosPhi = cos(phi);\n          return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);\n      }\n      vec3 LGL_N(SurfaceInteraction si, vec3 Csheen, vec3 V, vec3 L, vec3 H, out float pdf) {\n          pdf = 0.0;\n          if(L.z <= 0.0)\n              return vec3(0.0);\n          pdf = L.z * INVPI;\n          float LDotH = dot(L, H);\n          float FL = LGL_E(L.z);\n          float FV = LGL_E(V.z);\n          float Fh = LGL_E(LDotH);\n          float Fd90 = 0.5 + 2.0 * LDotH * LDotH * si.roughness;\n          float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n          float Fss90 = LDotH * LDotH * si.roughness;\n          float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n          float DisneyFakeSS = 1.25 * (Fss * (1.0 / (L.z + V.z) - 0.5) + 0.5);\n          vec3 Fsheen = Fh * si.sheen * Csheen;\n          return (INVPI * mix(Fd, DisneyFakeSS, si.LGL_BB) * si.color + Fsheen) * (1.0 - si.metalness) * (1.0 - si.LGL_BC);\n      }\n      vec3 LGL_O(SurfaceInteraction si, vec3 Cspec0, vec3 V, vec3 L, vec3 H, out float pdf) {\n          pdf = 0.0;\n          if(L.z <= 0.0)\n              return vec3(0.0);\n          float LDotH = dot(L, H);\n          float D = LGL_K(H.z, si.roughness);\n          pdf = D * H.z / (4.0 * LDotH);\n          vec3 F = LGL_H(Cspec0, si.metalness, si.eta, LDotH);\n          float G = LGL_I(abs(L.z), si.roughness) * LGL_I(abs(V.z), si.roughness);\n          return F * D * G;\n      }\n      vec3 LGL_P(SurfaceInteraction si, vec3 Cspec0, vec3 V, vec3 L, vec3 H, out float pdf) {\n          pdf = 0.0;\n          if(L.z >= 0.0)\n              return vec3(0.0);\n          float F = LGL_G(abs(dot(V, H)), si.eta);\n          float D = LGL_K(H.z, si.roughness);\n          float denomSqrt = dot(L, H) + dot(V, H) * si.eta;\n          pdf = D * H.z * abs(dot(L, H)) / (denomSqrt * denomSqrt);\n          float G = LGL_I(abs(L.z), si.roughness) * LGL_I(abs(V.z), si.roughness);\n          vec3 specColor = pow(si.color, vec3(0.5));\n          return specColor * (1.0 - si.metalness) * si.LGL_BC * (1.0 - F) * D * G * abs(dot(V, H)) * abs(dot(L, H)) * 4.0 * si.eta * si.eta / (denomSqrt * denomSqrt);\n      }\n      vec3 LGL_Q(SurfaceInteraction si, vec3 V, vec3 L, vec3 H, out float pdf) {\n          pdf = 0.0;\n          if(L.z <= 0.0)\n              return vec3(0.0);\n          float LDotH = dot(L, H);\n          float F = LGL_F(.04, LDotH);\n          float D = LGL_J(H.z, mix(0.1, 0.001, 1. - si.LGL_BA));\n          pdf = D * H.z / (4.0 * LDotH);\n          float G = LGL_I(L.z, 0.25) * LGL_I(V.z, 0.25);\n          return vec3(0.25 * si.clearcoat * F * D * G);\n      }\n      void LGL_R(SurfaceInteraction si, vec3 Cspec0, float fresnelWeight, out float LGL_S, out float LGL_T, out float LGL_U, out float LGL_V) {\n          LGL_S = max(LGL_AV(si.color), si.sheen) * (1.0 - si.metalness) * (1.0 - si.LGL_BC);\n          LGL_T = LGL_AV(mix(Cspec0, vec3(1.0), fresnelWeight));\n          LGL_U = (1.0 - fresnelWeight) * (1.0 - si.metalness) * si.LGL_BC * LGL_AV(si.color);\n          LGL_V = si.clearcoat * (1.0 - si.metalness);\n          float weightSum = LGL_S + LGL_T + LGL_U + LGL_V;\n          LGL_S /= weightSum;\n          LGL_T /= weightSum;\n          LGL_U /= weightSum;\n          LGL_V /= weightSum;\n      }\n      vec3 LGL_W(SurfaceInteraction si, vec3 V, vec3 N, out vec3 L, out float pdf, MaterialSamples LGL_AQomSamples) {\n          pdf = 0.0;\n          vec3 f = vec3(0.0);\n          vec2 bounceDirSample = LGL_AQomSamples.s3;\n          vec2 diffuseOrSpecular = LGL_AQomSamples.s4;\n          float r1 = bounceDirSample.x;\n          float r2 = bounceDirSample.y;\n          vec3 Cspec0, Csheen;\n          LGL_D(si, Cspec0, Csheen);\n          vec3 T, B;\n          LGL_AZ(N, T, B);\n          V = WorldToLocal(T, B, N, V);\n          float LGL_S, LGL_T, LGL_U, LGL_V;\n          float fresnelWeight = LGL_H(si.metalness, si.eta, V.z);\n          LGL_R(si, Cspec0, fresnelWeight, LGL_S, LGL_T, LGL_U, LGL_V);\n          float cdf[4];\n          cdf[0] = LGL_S;\n          cdf[1] = cdf[0] + LGL_T;\n          cdf[2] = cdf[1] + LGL_U;\n          cdf[3] = cdf[2] + LGL_V;\n          if(r1 < cdf[0]) {\n              r1 /= cdf[0];\n              L = LGL_A(r1, r2);\n              vec3 H = normalize(L + V);\n              f = LGL_N(si, Csheen, V, L, H, pdf);\n              pdf *= LGL_S;\n          } else if(r1 < cdf[1]) {\n              r1 = (r1 - cdf[0]) / (cdf[1] - cdf[0]);\n              vec3 H = ImportanceSampleLGL_K(si.roughness, r1, r2);\n              if(dot(V, H) < 0.0)\n                  H = -H;\n              L = normalize(reflect(-V, H));\n              f = LGL_O(si, Cspec0, V, L, H, pdf);\n              pdf *= LGL_T;\n          } else if(r1 < cdf[2]) {\n              r1 = (r1 - cdf[1]) / (cdf[2] - cdf[1]);\n              vec3 H = ImportanceSampleLGL_K(si.roughness, r1, r2);\n              if(dot(V, H) < 0.0)\n                  H = -H;\n              vec3 R = reflect(-V, H);\n              L = normalize(refract(-V, H, si.eta));\n              f = LGL_P(si, Cspec0, V, L, H, pdf);\n              pdf *= LGL_U;\n          } else {\n              r1 = (r1 - cdf[2]) / (1.0 - cdf[2]);\n              vec3 H = ImportanceSampleLGL_J(mix(0.1, 0.001, 1. - si.LGL_BA), r1, r2);\n              if(dot(V, H) < 0.0)\n                  H = -H;\n              L = normalize(reflect(-V, H));\n              f = LGL_Q(si, V, L, H, pdf);\n              pdf *= LGL_V;\n          }\n          L = LocalToWorld(T, B, N, L);\n          return f * abs(dot(N, L));\n      }\n      vec3 LGL_X(inout SurfaceInteraction si, vec3 V, vec3 L, out float bsdfPdf) {\n          bsdfPdf = 0.0;\n          vec3 f = vec3(0.0);\n          vec3 N = si.LGL_BL;\n          vec3 T, B;\n          LGL_AZ(N, T, B);\n          V = WorldToLocal(T, B, N, V);\n          L = WorldToLocal(T, B, N, L);\n          vec3 H;\n          if(L.z > 0.0) {\n              H = normalize(L + V);\n          } else {\n              H = normalize(L + V * si.eta);\n          }\n          if(dot(V, H) < 0.0) {\n              H = -H;\n          }\n          vec3 Cspec0, Csheen;\n          LGL_D(si, Cspec0, Csheen);\n          float LGL_S, LGL_T, LGL_U, LGL_V;\n          float fresnelWeight = LGL_H(si.metalness, si.eta, abs(dot(L, H)));\n          LGL_R(si, Cspec0, fresnelWeight, LGL_S, LGL_T, LGL_U, LGL_V);\n          float pdf;\n          if(LGL_S > 0.0 && L.z > 0.0) {\n              f += LGL_N(si, Csheen, V, L, H, pdf);\n              bsdfPdf += pdf * LGL_S;\n          }\n          if(LGL_T > 0.0 && L.z > 0.0 && V.z > 0.0) {\n              f += LGL_O(si, Cspec0, V, L, H, pdf);\n              bsdfPdf += pdf * LGL_T;\n          }\n          if(LGL_U > 0.0 && L.z < 0.0) {\n              f += LGL_P(si, Cspec0, V, L, H, pdf);\n              bsdfPdf += pdf * LGL_U;\n          }\n          if(LGL_V > 0.0 && L.z > 0.0 && V.z > 0.0) {\n              f += LGL_Q(si, V, L, H, pdf);\n              bsdfPdf += pdf * LGL_V;\n          }\n          return f * abs(L.z);\n      }\n      vec3 LGL_e(inout SurfaceInteraction si, in Path path, in vec2 s1, in vec2 s2) {\n          si.eta = dot(si.normal, si.LGL_BL) > 0.0 ? (1.0 / si.ior) : si.ior;\n          vec3 viewDir = -path.ray.d;\n          vec3 surfacePos = si.position + EPS * si.normal;\n          vec3 Li = vec3(0.0);\n          BsdfSampleRec bsdfSampleRec;\n          vec2 lightDirSample = s1;\n          vec2 envDirSample = s2;\n          vec3 lightDir;\n          vec2 uv;\n          float lightPdf;\n          bool brdfSample = false;\n      #ifndef CONST_COLOR_ENV\n          lightDir = LGL_d(envDirSample, uv, lightPdf);\n          LGL_AW(path.ray, surfacePos, lightDir);\n          if(!LGL_m(path.ray, INF - EPS)) {\n              vec3 irr = LGL_An(envMap, uv).rgb * envMapIntensity;\n              bsdfSampleRec.f = LGL_X(si, viewDir, lightDir, bsdfSampleRec.pdf);\n              if(bsdfSampleRec.pdf > 0.0) {\n                  float LGL_BR = LGL_Af(lightPdf, bsdfSampleRec.pdf);\n                  if(LGL_BR > 0.0) {\n                      Li += LGL_BR * bsdfSampleRec.f * irr / lightPdf;\n                  }\n              }\n          }\n      #endif\n      #if defined(NUM_LIGHTS)\n          LightSampleRec lightSampleRec;\n          Light light;\n          int i = int(lightDirSample.x * float(NUM_LIGHTS));\n          vec3 position = lights.position[i];\n          vec3 emission = lights.emission[i];\n          vec3 p1 = lights.p1[i];\n          vec3 p2 = lights.p2[i];\n          vec4 params = lights.params[i];\n          float radius = params.x;\n          float area = params.y;\n          float type = params.z;\n          float visible = params.w;\n          light = Light(position, emission, p1, p2, radius, area, type, visible);\n          LGL_Al(light, surfacePos, lightSampleRec, lightDirSample);\n          if(dot(lightSampleRec.direction, lightSampleRec.normal) < 0.0) {\n              LGL_AW(path.ray, surfacePos, lightSampleRec.direction);\n              if(!LGL_m(path.ray, lightSampleRec.dist - EPS)) {\n                  bsdfSampleRec.f = LGL_X(si, viewDir, lightSampleRec.direction, bsdfSampleRec.pdf);\n                  float LGL_BR = 1.0;\n                  if(light.area > 0.0 && bsdfSampleRec.pdf > 0.0) {\n                      LGL_BR = LGL_Af(lightSampleRec.pdf, bsdfSampleRec.pdf);\n                  }\n                  if(LGL_BR > 0.0) {\n                      Li += LGL_BR * bsdfSampleRec.f * lightSampleRec.emission / lightSampleRec.pdf;\n                  }\n              }\n          }\n      #endif\n          return Li;\n      }\n      layout(location = 0) out vec4 out_light;\n      void bounce(inout Path path, int depth, inout SurfaceInteraction si, inout BsdfSampleRec bsdfSampleRec, in LightSampleRec lightSampleRec) {\n          if(!si.LGL_BK) {\n              if(depth == 0 && enviromentVisible == 0.) {\n                  path.alpha = 0.0;\n                  path.LGL_BQ = true;\n                  return;\n              }\n      #ifdef CONST_COLOR_ENV\n              path.li += backgroundColor * path.beta;\n              path.LGL_BQ = true;\n              return;\n      #else\n              float LGL_BR = 1.0;\n              if(depth > 0) {\n                  float lightPdf = LGL_c(LGL_Y(path.ray.d));\n                  LGL_BR = LGL_Af(bsdfSampleRec.pdf, lightPdf);\n              }\n              vec3 irr = LGL_Z(path.ray.d) * envMapIntensity;\n              path.li += LGL_BR * path.beta * irr;\n              path.LGL_BQ = true;\n              return;\n      #endif\n          }\n          if(si.LGL_BI) {\n              path.li += LGL_Ag(path.ray, depth, lightSampleRec, bsdfSampleRec) * path.beta;\n              path.LGL_BQ = true;\n              return;\n          }\n          if(dot(si.normal, si.LGL_BL) > 0.0) {\n              path.LGL_BS = vec3(0.0);\n          }\n          path.li += path.beta * si.emissive;\n          path.beta *= exp(-path.LGL_BS * si.t);\n          MaterialSamples LGL_AQomSamples = getRandomMaterialSamples();\n          if(si.LGL_BH == DISNEY) {\n              path.li += LGL_e(si, path, LGL_AQomSamples.s1, LGL_AQomSamples.s2) * path.beta;\n          }\n          bsdfSampleRec.f = LGL_W(si, -path.ray.d, si.LGL_BL, bsdfSampleRec.L, bsdfSampleRec.pdf, LGL_AQomSamples);\n          if(dot(si.LGL_BL, bsdfSampleRec.L) < 0.0) {\n              path.LGL_BS = -log(si.extinction) / si.LGL_BE;\n          }\n          if(bsdfSampleRec.pdf > 0.0) {\n              path.beta *= bsdfSampleRec.f / bsdfSampleRec.pdf;\n          } else {\n              path.LGL_BQ = true;\n              return;\n          }\n          if(depth >= 2) {\n              float q = 1.0 - LGL_AV(path.beta);\n              if(LGL_AQomSample() < q) {\n                  path.LGL_BQ = true;\n                  return;\n              }\n              path.beta /= 1.0 - q;\n          }\n          LGL_AW(path.ray, si.position + EPS * bsdfSampleRec.L, bsdfSampleRec.L);\n      }\n      vec4 LGL_Ao(inout Ray ray) {\n          SurfaceInteraction si;\n          Path path;\n          BsdfSampleRec bsdfSampleRec;\n          LightSampleRec lightSampleRec;\n          path.ray = ray;\n          path.li = vec3(0);\n          path.alpha = 1.0;\n          path.LGL_BQ = false;\n          path.LGL_BR = 1.0;\n          path.LGL_BS = vec3(0.0);\n          path.beta = vec3(1.0);\n          for(int i = 0; i < bounces; i++) {\n              if(path.LGL_BQ) {\n                  return vec4(path.li, path.alpha);\n              }\n              LGL_n(path.ray, si, lightSampleRec, i);\n              LGL_o(path.ray, si, lightSampleRec, i);\n              bounce(path, i, si, bsdfSampleRec, lightSampleRec);\n          }\n          return vec4(path.li, path.alpha);\n      }\n      void main() {\n          LGL_AS(frameCount);\n          vec2 vCoordAntiAlias = vCoord + jitter;\n          vec3 direction = normalize(vec3(vCoordAntiAlias - 0.5, -1.0) * vec3(camera.aspect, 1.0, camera.fov));\n      #ifdef USE_LENS_CAMERA\n          vec2 lensPoint = camera.aperture * LGL_Aa(vec2(LGL_AN(vCoordAntiAlias)));\n          vec3 focusPoint = -direction * camera.focus / direction.z;\n          vec3 origin = vec3(lensPoint, 0.0);\n          direction = normalize(focusPoint - origin);\n          origin = vec3(camera.transform * vec4(origin, 1.0));\n          direction = mat3(camera.transform) * direction;\n      #else\n          vec3 origin = camera.transform[3].xyz;\n          direction = mat3(camera.transform) * direction;\n      #endif\n          Ray cam;\n          LGL_AW(cam, origin, direction);\n          vec4 liAndAlpha = LGL_Ao(cam);\n          if(!(liAndAlpha.x < INF && liAndAlpha.x > -EPS)) {\n              liAndAlpha = vec4(0, 0, 0, 1);\n          }\n          out_light = liAndAlpha;\n      }"};async function O(e,{bounces:n,decomposedScene:t,fullscreenQuad:a,materialBuffer:i,mergedMesh:o,optionalExtensions:r,envMapIntensity:s,enviromentVisible:l,useWorker:f,loadingCallback:u}){const p=await async function({decomposedScene:e,fullscreenQuad:n,gl:t,materialBuffer:a,mergedMesh:i,optionalExtensions:o,useWorker:r,loadingCallback:s}){const{OES_texture_float_linear:l}=o,{camera:f,meshLightsNum:d,isTextureEnv:c}=e,{geometry:u}=i;"function"==typeof(null==s?void 0:s.onProgress)&&s.onProgress("Building BVH...");const p=await V(u,r),m=u.index.count/3,L=_(t,{defines:{OES_texture_float_linear:l,BVH_COLUMNS:k(p.count).columnsLog,INDEX_COLUMNS:k(m).columnsLog,VERTEX_COLUMNS:k(u.attributes.position.count).columnsLog,STACK_SIZE:p.maxDepth,USE_LENS_CAMERA:f.isLensCamera,NUM_LIGHTS:d,CONST_COLOR_ENV:!c,...a.defines},fragment:H,vertex:n.vertexShader});L.setTexture("diffuseMap",a.textures.diffuseMap),L.setTexture("normalMap",a.textures.normalMap),L.setTexture("pbrMap",a.textures.pbrMap),L.setTexture("pbrSGMap",a.textures.pbrSGMap),a.textures.emissiveMap&&L.setTexture("emissiveMap",a.textures.emissiveMap);return L.setTexture("positionBuffer",Z(t,u.getAttribute("position").array,3)),L.setTexture("normalBuffer",Z(t,u.getAttribute("normal").array,3)),L.setTexture("uvBuffer",Z(t,u.getAttribute("uv").array,2)),L.setTexture("bvhBuffer",Z(t,p.buffer,4)),L}({bounces:n,decomposedScene:t,fullscreenQuad:a,gl:e,materialBuffer:i,mergedMesh:o,optionalExtensions:r,useWorker:f,loadingCallback:u}),m=[];let L;function x(e){m.length=0,e=d(e,2,8);for(let n=1;n<=e;n++)m.push(2,2,2,2),n>=2&&m.push(1);p.setUniform("bounces",e),L&&(L.strataCount=-1)}function h(n){const{OES_texture_float_linear:t}=r,{environment:a,isTextureEnv:i}=n;if(i){var o;let n;if(null!=(o=a.data)&&o.isTexture?n=Q(a):console.warn(`No support environment type: ${a.data}`),n){const a=c(e,{data:n.data,storage:n.dataFormat,minFilter:t?e.LINEAR:e.NEAREST,magFilter:t?e.LINEAR:e.NEAREST,width:n.width,height:n.height});p.setTexture("envMap",a);const i=D(n);p.setTexture("envMapDistribution",c(e,{data:i.data,storage:"float",width:i.width,height:i.height})),p.setUniform("envMapIntensity",s)}}else{const e=a.data;e&&e.isColor?p.setUniform("backgroundColor",[e.r,e.g,e.b]):p.setUniform("backgroundColor",[0,0,0])}A(l)}function v(e){const{meshLights:n}=e;n&&(p.setUniform("lights.position[0]",n.position),p.setUniform("lights.emission[0]",n.emission),p.setUniform("lights.p1[0]",n.p1),p.setUniform("lights.p2[0]",n.p2),p.setUniform("lights.params[0]",n.params))}function A(e){p.setUniform("enviromentVisible",Number(e))}function g(){p.setUniform("stratifiedSamples[0]",L.next())}return x(n),h(t),v(t),L=W(1,m),{bindTextures:function(){p.bindTextures()},draw:function(){p.useProgram(!1),a.draw()},outputLocs:p.outputLocs,textures:p.textures,setSize:function(e,n){p.setUniform("pixelSize",1/e,1/n)},setCamera:function(e){p.setUniform("camera.transform",e.matrixWorld.elements),p.setUniform("camera.aspect",e.aspect),p.setUniform("camera.fov",.5/Math.tan(.5*Math.PI*e.fov/180)),e.isLensCamera&&(p.setUniform("camera.aperture",e.aperture),p.setUniform("camera.focus",e.focus))},setGBuffers:function({position:e}){p.setTexture("gPosition",e)},setNoise:function(n){p.setTexture("noiseTex",c(e,{data:n,wrapS:e.REPEAT,wrapT:e.REPEAT,storage:"halfFloat"}))},setJitter:function(e,n){p.setUniform("jitter",e,n)},setFrameCount:function(e){p.setUniform("frameCount",e)},setStrataCount:function(e){e>1&&e!==L.strataCount?L=W(e,m):L.restart(),p.setUniform("strataSize",1/e),g()},nextSeed:g,setEnvMapIntensity:function(e){p.setUniform("envMapIntensity",e)},setEnviromentVisible:A,updateBounces:x,updateEnvLight:h,updateMeshLight:v}}function k(e){const n=Math.round(Math.log2(Math.sqrt(e))),t=2**n,a=Math.ceil(e/t);return{columnsLog:n,columns:t,rows:a,size:a*t}}function Z(e,n,t){const a=k(n.length/t);return c(e,{data:K(n,t*a.size),width:a.columns,height:a.rows})}function K(e,n){const t=new e.constructor(n);return t.set(e),t}var q={source:"\n        vec4 LGL_An(sampler2D map, vec2 uv) {\n        #ifdef OES_texture_float_linear\n            return texture(map, uv);\n        #else\n            vec2 size = vec2(textureSize(map, 0));\n            vec2 texelSize = 1.0 / size;\n            uv = uv * size - 0.5;\n            vec2 f = fract(uv);\n            uv = floor(uv) + 0.5;\n            vec4 s1 = texture(map, (uv + vec2(0, 0)) * texelSize);\n            vec4 s2 = texture(map, (uv + vec2(1, 0)) * texelSize);\n            vec4 s3 = texture(map, (uv + vec2(0, 1)) * texelSize);\n            vec4 s4 = texture(map, (uv + vec2(1, 1)) * texelSize);\n            return mix(mix(s1, s2, f.x), mix(s3, s4, f.x), f.y);\n        #endif\n        }\n        layout(location = 0) out vec4 out_light;\n        layout(location = 1) out vec4 out_momentLengthVariance;\n        in vec2 vCoord;\n        uniform mediump sampler2D lightTex;\n        uniform mediump sampler2D positionTex;\n        uniform mediump sampler2D colorTex;\n        uniform mediump sampler2D previousLightTex;\n        uniform mediump sampler2D previousPositionTex;\n        uniform mediump sampler2D previousColorTex;\n        uniform mediump sampler2D previousMomentLengthVarianceTex;\n        uniform mat4 historyCamera;\n        uniform float colorBlendFactor;\n        uniform float momentBlendFactor;\n        uniform float demodulateAlbedo;\n        vec2 LGL_As(vec3 position) {\n            vec4 historyCoord = historyCamera * vec4(position, 1.0);\n            return 0.5 * historyCoord.xy / historyCoord.w + 0.5;\n        }\n        float LGL_At(sampler2D meshIdTex, vec2 vCoord) {\n            return floor(texture(meshIdTex, vCoord).w);\n        }\n        float LGL_Au(float histMeshId, float currentMeshId, ivec2 coord, ivec2 size) {\n            if(histMeshId != currentMeshId) {\n                return 0.0;\n            }\n            if(any(greaterThanEqual(coord, size))) {\n                return 0.0;\n            }\n            return 1.0;\n        }\n        void main() {\n            vec3 currentPosition = LGL_An(positionTex, vCoord).xyz;\n            float currentMeshId = LGL_At(positionTex, vCoord);\n            vec4 accumulatedLight = texture(lightTex, vCoord);\n            vec3 currentLight = accumulatedLight.rgb / accumulatedLight.a;\n            vec2 hCoord = LGL_As(currentPosition);\n            vec2 hSizef = vec2(textureSize(previousLightTex, 0));\n            vec2 hSizeInv = 1.0 / hSizef;\n            ivec2 hSize = ivec2(hSizef);\n            vec2 hTexelf = hCoord * hSizef - 0.5;\n            ivec2 hTexel = ivec2(hTexelf);\n            vec2 f = fract(hTexelf);\n            ivec2 texel[] = ivec2[] (hTexel + ivec2(0, 0), hTexel + ivec2(1, 0), hTexel + ivec2(0, 1), hTexel + ivec2(1, 1));\n            float weights[] = float[] ((1.0 - f.x) * (1.0 - f.y), f.x * (1.0 - f.y), (1.0 - f.x) * f.y, f.x * f.y);\n            vec4 historyLight = vec4(0.);;\n            vec2 historyMoment = vec2(0.);\n            float historyLength = 0.;\n            float sum = 0.;\n            float luminance = 0.2126 * currentLight.x + 0.7152 * currentLight.y + 0.0722 * currentLight.z;\n            float N = texelFetch(previousMomentLengthVarianceTex, hTexel, 0).b;\n            if(N > 0.0 && currentMeshId > 0.0) {\n                for(int i = 0; i < 4; i++) {\n                    vec2 gCoord = (vec2(texel[i]) + 0.5) * hSizeInv;\n                    float histMeshId = LGL_At(previousPositionTex, gCoord);\n                    float isValid = LGL_Au(histMeshId, currentMeshId, texel[i], hSize);\n                    float weight = isValid * weights[i];\n                    historyLight += weight * texelFetch(previousLightTex, texel[i], 0);\n                    historyMoment += weight * texelFetch(previousMomentLengthVarianceTex, texel[i], 0).rg;\n                    sum += weight;\n                }\n                if(sum > 0.0) {\n                    historyLight /= sum;\n                    historyMoment /= sum;\n                } else {\n                    hTexel = ivec2(hTexelf + 0.5);\n                    for(int x = -1; x <= 1; x++) {\n                        for(int y = -1; y <= 1; y++) {\n                            ivec2 texel = hTexel + ivec2(x, y);\n                            vec2 gCoord = (vec2(texel) + 0.5) * hSizeInv;\n                            float histMeshId = LGL_At(previousPositionTex, gCoord);\n                            float isValid = LGL_Au(histMeshId, currentMeshId, texel, hSize);\n                            float weight = isValid;\n                            historyLight += weight * texelFetch(previousLightTex, texel, 0);\n                            historyMoment += weight * texelFetch(previousMomentLengthVarianceTex, texel, 0).rg;\n                            sum += weight;\n                        }\n                    }\n                    historyLight = sum > 0.0 ? historyLight / sum : historyLight;\n                    historyMoment = sum > 0.0 ? historyMoment / sum : historyMoment;\n                }\n                if(sum > 0.0) {\n                    historyLength = N + 1.;\n                    float color_alpha_min = colorBlendFactor;\n                    float moment_alpha_min = momentBlendFactor;\n                    float color_alpha = max(1.0 / historyLength, color_alpha_min);\n                    float moment_alpha = max(1.0 / historyLength, moment_alpha_min);\n                    out_light = color_alpha * accumulatedLight + historyLight * (1. - color_alpha);\n                    float first_moment = moment_alpha * historyMoment.x + (1.0 - moment_alpha) * luminance;\n                    float second_moment = moment_alpha * historyMoment.y + (1.0 - moment_alpha) * luminance * luminance;\n                    float variance = second_moment - first_moment * first_moment;\n                    out_momentLengthVariance = vec4(first_moment, second_moment, historyLength, variance);\n                    return;\n                }\n            }\n            out_light = accumulatedLight;\n            out_momentLengthVariance = vec4(luminance, luminance * luminance, 1., 100.);\n        }\n    "};var J={source:"\n          vec4 LGL_An(sampler2D map, vec2 uv) {\n          #ifdef OES_texture_float_linear\n              return texture(map, uv);\n          #else\n              vec2 size = vec2(textureSize(map, 0));\n              vec2 texelSize = 1.0 / size;\n              uv = uv * size - 0.5;\n              vec2 f = fract(uv);\n              uv = floor(uv) + 0.5;\n              vec4 s1 = texture(map, (uv + vec2(0, 0)) * texelSize);\n              vec4 s2 = texture(map, (uv + vec2(1, 0)) * texelSize);\n              vec4 s3 = texture(map, (uv + vec2(0, 1)) * texelSize);\n              vec4 s4 = texture(map, (uv + vec2(1, 1)) * texelSize);\n              return mix(mix(s1, s2, f.x), mix(s3, s4, f.x), f.y);\n          #endif\n          }\n          layout(location = 0) out vec4 out_color;\n          in vec2 vCoord;\n          uniform sampler2D lightTex;\n          uniform vec2 lightScale;\n          uniform int toneMappingFun;\n          vec3 linear(vec3 color) {\n              return color;\n          }\n          vec3 LGL_Av(vec3 color) {\n              return clamp(color / (vec3(1.0) + color), vec3(0.0), vec3(1.0));\n          }\n          vec3 LGL_Aw(vec3 color) {\n              color = max(vec3(0.0), color - 0.004);\n              return pow((color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06), vec3(2.2));\n          }\n          vec3 LGL_Ax(vec3 color) {\n              return clamp((color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59) + 0.14), vec3(0.0), vec3(1.0));\n          }\n          void main() {\n              vec4 upscaledLight = texture(lightTex, lightScale * vCoord);\n              vec3 light = upscaledLight.rgb / upscaledLight.a;\n              if(toneMappingFun == 0) {\n                  light = linear(light);\n              }\n              if(toneMappingFun == 1) {\n                  light = LGL_Ax(light);\n              }\n              if(toneMappingFun == 2) {\n                  light = LGL_Av(light);\n              }\n              if(toneMappingFun == 3) {\n                  light = LGL_Aw(light);\n              }\n              light = pow(light, vec3(1.0 / 2.2));\n              if(upscaledLight.a == 0.) {\n                  out_color = vec4(light, 0.0);\n              } else {\n                  out_color = vec4(light, 1.0);\n              }\n          }\n    "};const j={[a.LinearToneMapping]:0,[a.ACESFilmicToneMapping]:1,[a.ReinhardToneMapping]:2,[a.CineonToneMapping]:3};var $={source:"\n        in vec3 aPosition;\n        in vec3 aNormal;\n        in vec2 aUv;\n        in ivec2 aMaterialMeshIndex;\n        uniform mat4 projView;\n        out vec3 vPosition;\n        out vec3 vNormal;\n        out vec2 vUv;\n        flat out ivec2 vMaterialMeshIndex;\n        void main() {\n            vPosition = aPosition;\n            vNormal = aNormal;\n            vUv = aUv;\n            vMaterialMeshIndex = aMaterialMeshIndex;\n            gl_Position = projView * vec4(aPosition, 1);\n        }\n    "},ee={source:"\n        #define PI 3.14159265359\n        #define TWOPI 6.28318530718\n        #define INVPI 0.31830988618\n        #define INVPI2 0.10132118364\n        #define EPS 0.0001\n        #define ONE_MINUS_EPS 0.999999\n        #define INF 1000000.0\n        #define ROUGHNESS_MIN 0.001\n        uniform Materials {\n            vec4 colorAndMaterialType[NUM_MATERIALS];\n            vec4 roughnessMetalnessNormalScale[NUM_MATERIALS];\n            vec4 alphaSpecularTintSheenSheenTint[NUM_MATERIALS];\n            vec4 clearcoaRoughnessSubfaceTransmission[NUM_MATERIALS];\n            vec4 iorAtDistanceAnisotropicWorkflow[NUM_MATERIALS];\n            vec4 extinction[NUM_MATERIALS];\n            vec4 specularColorGlossiness[NUM_MATERIALS];\n        #if defined(NUM_DIFFUSE_MAPS) || defined(NUM_NORMAL_MAPS) || defined(NUM_PBR_MAPS)\n            ivec4 diffuseNormalRoughnessMetalnessMapIndex[NUM_MATERIALS];\n        #endif\n        #if defined(NUM_EMISSIVE_MAPS) || defined(NUM_PBR_SG_MAPS)\n            ivec4 emissiveSpecularGlossinessMapIndex[NUM_MATERIALS];\n        #endif\n        #if defined(NUM_DIFFUSE_MAPS) || defined(NUM_NORMAL_MAPS)\n            vec4 diffuseNormalMapSize[NUM_DIFFUSE_NORMAL_MAPS];\n        #endif\n        #if defined(NUM_PBR_MAPS)\n            vec2 pbrMapSize[NUM_PBR_MAPS];\n        #else\n        #if defined(NUM_PBR_SG_MAPS)\n            vec2 pbrMapSize[NUM_PBR_SG_MAPS];\n        #else\n        #if defined(NUM_EMISSIVE_MAPS)\n            vec2 pbrMapSize[NUM_EMISSIVE_MAPS];\n        #endif\n        #endif\n        #endif\n        } materials;\n        #ifdef NUM_DIFFUSE_MAPS\n        uniform mediump sampler2DArray diffuseMap;\n        #endif\n        #ifdef NUM_NORMAL_MAPS\n        uniform mediump sampler2DArray normalMap;\n        #endif\n        #ifdef NUM_PBR_MAPS\n        uniform mediump sampler2DArray pbrMap;\n        #endif\n        #ifdef NUM_PBR_SG_MAPS\n        uniform mediump sampler2DArray pbrSGMap;\n        #endif\n        #ifdef NUM_EMISSIVE_MAPS\n        uniform mediump sampler2DArray emissiveMap;\n        #endif\n        float LGL_p(int materialIndex) {\n            return materials.colorAndMaterialType[materialIndex].w;\n        }\n        float LGL_q(int materialIndex) {\n            return materials.iorAtDistanceAnisotropicWorkflow[materialIndex].w;\n        }\n        vec3 LGL_r(int materialIndex, vec2 uv) {\n            vec3 emissive = vec3(0.0);\n        #ifdef NUM_EMISSIVE_MAPS\n            int emissiveMapIndex = materials.emissiveSpecularGlossinessMapIndex[materialIndex].x;\n            if(emissiveMapIndex >= 0) {\n                emissive = texture(emissiveMap, vec3(uv * materials.pbrMapSize[emissiveMapIndex].xy, emissiveMapIndex)).rgb;\n            }\n        #endif\n            return emissive;\n        }\n        vec3 LGL_s(int materialIndex, vec2 uv) {\n            vec3 specularColor = materials.specularColorGlossiness[materialIndex].rgb;\n        #ifdef NUM_PBR_SG_MAPS\n            int specularMapIndex = materials.emissiveSpecularGlossinessMapIndex[materialIndex].y;\n            if(specularMapIndex >= 0) {\n                vec3 texelSpecular = texture(pbrSGMap, vec3(uv * materials.pbrMapSize[specularMapIndex].xy, specularMapIndex)).rgb;\n                texelSpecular = pow(texelSpecular, vec3(2.2));\n                specularColor *= texelSpecular;\n            }\n        #endif\n            return specularColor;\n        }\n        float LGL_t(int materialIndex, vec2 uv) {\n            float glossiness = materials.specularColorGlossiness[materialIndex].a;\n        #ifdef NUM_PBR_SG_MAPS\n            int glossinessMapIndex = materials.emissiveSpecularGlossinessMapIndex[materialIndex].z;\n            if(glossinessMapIndex >= 0) {\n                float texelGlossiness = texture(pbrSGMap, vec3(uv * materials.pbrMapSize[glossinessMapIndex].xy, glossinessMapIndex)).a;\n                glossiness *= texelGlossiness;\n            }\n        #endif\n            return glossiness;\n        }\n        float LGL_u(int materialIndex, vec2 uv) {\n            float LGL_BG = LGL_q(materialIndex);\n            float roughness = 0.0;\n            if(LGL_BG > 0.1) {\n                roughness = 1.0 - LGL_t(materialIndex, uv);\n            } else {\n                roughness = materials.roughnessMetalnessNormalScale[materialIndex].x;\n        #ifdef NUM_PBR_MAPS\n                int roughnessMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialIndex].z;\n                if(roughnessMapIndex >= 0) {\n                    roughness *= texture(pbrMap, vec3(uv * materials.pbrMapSize[roughnessMapIndex].xy, roughnessMapIndex)).g;\n                }\n        #endif\n            }\n            return roughness * roughness;\n        }\n        float LGL_v(const vec3 v) {\n            return max(v.x, max(v.y, v.z));\n        }\n        float LGL_w(const vec3 specularColor) {\n            return LGL_v(specularColor);\n        }\n        vec3 LGL_x(const vec3 baseColor, float metallic) {\n            return baseColor * (1.0 - metallic);\n        }\n        float LGL_y(int materialIndex, vec2 uv) {\n            float LGL_BG = LGL_q(materialIndex);\n            float metalness = 0.0;\n            if(LGL_BG > 0.1) {\n                vec3 specularFactor = LGL_s(materialIndex, uv);\n                metalness = LGL_w(specularFactor);\n            } else {\n                metalness = materials.roughnessMetalnessNormalScale[materialIndex].y;\n        #ifdef NUM_PBR_MAPS\n                int metalnessMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialIndex].w;\n                if(metalnessMapIndex >= 0) {\n                    metalness *= texture(pbrMap, vec3(uv * materials.pbrMapSize[metalnessMapIndex].xy, metalnessMapIndex)).b;\n                }\n        #endif\n            }\n            return metalness;\n        }\n        vec3 LGL_z(int materialIndex, vec2 uv) {\n            vec3 color = materials.colorAndMaterialType[materialIndex].rgb;\n        #ifdef NUM_DIFFUSE_MAPS\n            int diffuseMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialIndex].x;\n            if(diffuseMapIndex >= 0) {\n                color *= texture(diffuseMap, vec3(uv * materials.diffuseNormalMapSize[diffuseMapIndex].xy, diffuseMapIndex)).rgb;\n            }\n        #endif\n            float LGL_BG = LGL_q(materialIndex);\n            if(LGL_BG > 0.1) {\n                vec3 specularFactor = LGL_s(materialIndex, uv);\n                color = LGL_x(color, LGL_w(specularFactor));\n            }\n            return color;\n        }\n        vec3 LGL_AA(int materialIndex, vec2 uv, vec3 normal, vec3 dp1, vec3 dp2, vec2 duv1, vec2 duv2, inout vec3 tangent, inout vec3 bitangent) {\n            vec3 dp2perp = cross(dp2, normal);\n            vec3 dp1perp = cross(normal, dp1);\n            vec3 dpdu = dp2perp * duv1.x + dp1perp * duv2.x;\n            vec3 dpdv = dp2perp * duv1.y + dp1perp * duv2.y;\n            float invmax = inversesqrt(max(dot(dpdu, dpdu), dot(dpdv, dpdv)));\n            dpdu *= invmax;\n            dpdv *= invmax;\n            tangent = normalize(dpdu);\n            bitangent = normalize(dpdv);\n        #ifdef NUM_NORMAL_MAPS\n            int normalMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialIndex].y;\n            if(normalMapIndex >= 0) {\n                vec3 n = 2.0 * texture(normalMap, vec3(uv * materials.diffuseNormalMapSize[normalMapIndex].zw, normalMapIndex)).rgb - 1.0;\n                n.xy *= materials.roughnessMetalnessNormalScale[materialIndex].zw;\n                mat3 tbn = mat3(dpdu, dpdv, normal);\n                return normalize(tbn * n);\n            } else {\n                return normal;\n            }\n        #endif\n            return normal;\n        }\n        float LGL_AD(int materialIndex, vec2 uv) {\n            float alpha = materials.alphaSpecularTintSheenSheenTint[materialIndex].x;\n        #ifdef NUM_DIFFUSE_MAPS\n            int diffuseMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialIndex].x;\n            if(diffuseMapIndex >= 0) {\n                alpha *= texture(diffuseMap, vec3(uv * materials.diffuseNormalMapSize[diffuseMapIndex].xy, diffuseMapIndex)).a;\n            }\n        #endif\n            return alpha;\n        }\n        float LGL_AB(int materialIndex) {\n            return materials.alphaSpecularTintSheenSheenTint[materialIndex].y;\n        }\n        float LGL_AC(int materialIndex) {\n            return materials.alphaSpecularTintSheenSheenTint[materialIndex].z;\n        }\n        float LGL_ACTint(int materialIndex) {\n            return materials.alphaSpecularTintSheenSheenTint[materialIndex].w;\n        }\n        float LGL_AF(int materialIndex) {\n            return materials.clearcoaRoughnessSubfaceTransmission[materialIndex].x;\n        }\n        float LGL_AFRoughness(int materialIndex) {\n            return materials.clearcoaRoughnessSubfaceTransmission[materialIndex].y;\n        }\n        float LGL_AH(int materialIndex) {\n            return materials.clearcoaRoughnessSubfaceTransmission[materialIndex].z;\n        }\n        float LGL_AI(int materialIndex) {\n            return materials.clearcoaRoughnessSubfaceTransmission[materialIndex].w;\n        }\n        float LGL_AJ(int materialIndex) {\n            return materials.iorAtDistanceAnisotropicWorkflow[materialIndex].x;\n        }\n        float LGL_AK(int materialIndex) {\n            return materials.iorAtDistanceAnisotropicWorkflow[materialIndex].y;\n        }\n        float LGL_AL(int materialIndex) {\n            return materials.iorAtDistanceAnisotropicWorkflow[materialIndex].z;\n        }\n        vec3 LGL_AM(int materialIndex) {\n            return materials.extinction[materialIndex].rgb;\n        }\n        layout(location = 0) out vec4 out_position;\n        layout(location = 1) out vec4 out_normal;\n        layout(location = 2) out vec4 out_color;\n        in vec3 vPosition;\n        in vec3 vNormal;\n        in vec2 vUv;\n        flat in ivec2 vMaterialMeshIndex;\n        vec3 LGL_BMs(vec3 pos) {\n            vec3 fdx = dFdx(pos);\n            vec3 fdy = dFdy(pos);\n            return cross(fdx, fdy);\n        }\n        void main() {\n            int materialIndex = vMaterialMeshIndex.x;\n            int meshIndex = vMaterialMeshIndex.y;\n            vec2 uv = fract(vUv);\n            vec3 color = LGL_z(materialIndex, uv);\n            float LGL_BH = LGL_p(materialIndex);\n            vec3 normal = normalize(vNormal);\n            vec3 LGL_BM = normalize(LGL_BMs(vPosition));\n            normal *= sign(dot(normal, LGL_BM));\n        #ifdef NUM_NORMAL_MAPS\n            vec3 dp1 = dFdx(vPosition);\n            vec3 dp2 = dFdy(vPosition);\n            vec2 duv1 = dFdx(vUv);\n            vec2 duv2 = dFdy(vUv);\n            vec3 tangent, bitangent;\n            normal = LGL_AA(materialIndex, uv, normal, dp1, dp2, duv1, duv2, tangent, bitangent);\n        #endif\n            out_position = vec4(vPosition, float(meshIndex) + EPS);\n            out_normal = vec4(normal, LGL_BH);\n            out_color = vec4(color, 0.);\n        }\n    "};function ne(e,{materialBuffer:t,mergedMesh:a}){const i=_(e,{defines:t.defines,vertex:$,fragment:ee});i.setTexture("diffuseMap",t.textures.diffuseMap),i.setTexture("normalMap",t.textures.normalMap);const o=a.geometry,r=o.getIndex().count,s=e.createVertexArray();e.bindVertexArray(s),function(e,n,t){te(e,n.attribLocs.aPosition,t.getAttribute("position")),te(e,n.attribLocs.aNormal,t.getAttribute("normal")),te(e,n.attribLocs.aUv,t.getAttribute("uv")),te(e,n.attribLocs.aMaterialMeshIndex,t.getAttribute("materialMeshIndex")),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,e.createBuffer()),e.bufferData(e.ELEMENT_ARRAY_BUFFER,t.getIndex().array,e.STATIC_DRAW)}(e,i,o),e.bindVertexArray(null);let l,f=0,d=0;let c=new n.Matrix4;return{draw:function(){c.copy(l.projectionMatrix),c.elements[8]+=2*f,c.elements[9]+=2*d,c.multiply(l.matrixWorldInverse),i.setUniform("projView",c.elements),e.bindVertexArray(s),i.useProgram(),e.enable(e.DEPTH_TEST),e.drawElements(e.TRIANGLES,r,e.UNSIGNED_INT,0),e.disable(e.DEPTH_TEST)},outputLocs:i.outputLocs,setCamera:function(e){l=e},setJitter:function(e,n){f=e,d=n}}}function te(e,n,t){if(void 0===n)return;const{itemSize:a,array:i}=t;if(e.enableVertexAttribArray(n),e.bindBuffer(e.ARRAY_BUFFER,e.createBuffer()),e.bufferData(e.ARRAY_BUFFER,i,e.STATIC_DRAW),i instanceof Float32Array)e.vertexAttribPointer(n,a,e.FLOAT,!1,0,0);else{if(!(i instanceof Int32Array))throw"Unsupported buffer type";e.vertexAttribIPointer(n,a,e.INT,0,0)}}function ae(e,{color:n,depth:t}){const a=e.createFramebuffer();function i(){e.bindFramebuffer(e.FRAMEBUFFER,a)}function o(){e.bindFramebuffer(e.FRAMEBUFFER,null)}return function(){i();const a=[];for(let t in n){t=Number(t),void 0===t&&console.error("invalid location");const i=n[t];e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0+t,i.target,i.texture,0),a.push(e.COLOR_ATTACHMENT0+t)}e.drawBuffers(a),t&&e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,t.target,t.texture),o()}(),{color:n,bind:i,unbind:o}}function ie(e,n,t,a,i,o,r){const s=Math.min(r.length/o,t);for(let t=0;t<s;t++)for(let s=0;s<o;s++)e[n](a+t*i+4*s,r[o*t+s],!0)}function oe(e,n){const t={textures:[],indices:{}};for(const a of n)t.indices[a]=re(e,a,t.textures);return t}function re(e,n,t){const a=[];for(const i of e){if(i[n]&&i[n].image){let e=t.length;for(let a=0;a<t.length;a++)if(t[a]===i[n]){e=a;break}e===t.length&&t.push(i[n]),a.push(e)}else a.push(-1)}return a}function se(e,n){const t=function(e,n){const t={};for(const a of n){const n=[],i=re(e,a,n);t[a]={indices:i,textures:n}}return t}(n,["map","normalMap","emissiveMap"]),a=oe(n,["roughnessMap","metalnessMap"]),i=oe(n,["specularMap","glossinessMap"]),o={},s={};if(s.color=n.map((e=>e.color)),s.roughness=n.map((e=>e.roughness)),s.metalness=n.map((e=>e.metalness)),s.normalScale=n.map((e=>e.normalScale)),s.specularTint=n.map((e=>e.specularTint)),s.sheen=n.map((e=>e.sheen)),s.sheenTint=n.map((e=>e.sheenTint)),s.clearcoat=n.map((e=>e.clearcoat)),s.clearcoatRoughness=n.map((e=>e.clearcoatRoughness)),s.transmission=n.map((e=>e.transmission)),s.subsurface=n.map((e=>e.subsurface)),s.ior=n.map((e=>e.ior)),s.atDistance=n.map((e=>e.atDistance)),s.extinction=n.map((e=>e.extinction)),s.alpha=n.map((e=>e.alpha)),s.workflow=n.map((e=>"Metalness"===e.workflow?0:1)),s.specularColor=n.map((e=>e.specularColor)),s.glossiness=n.map((e=>e.glossiness)),s.type=n.map((()=>0)),t.map.textures.length>0){const{relativeSizes:n,texture:a}=le(e,t.map.textures,!0,4);s.diffuseMap=a,s.diffuseMapSize=n,s.diffuseMapIndex=t.map.indices}if(t.normalMap.textures.length>0){const{relativeSizes:n,texture:a}=le(e,t.normalMap.textures,!1);o.normalMap=a,s.normalMapSize=n,s.normalMapIndex=t.normalMap.indices}if(a.textures.length>0){const{relativeSizes:n,texture:t}=le(e,a.textures,!1);o.pbrMap=t,s.pbrMapSize=n,s.roughnessMapIndex=a.indices.roughnessMap,s.metalnessMapIndex=a.indices.metalnessMap}if(i.textures.length>0){const{relativeSizes:n,texture:t}=le(e,i.textures,!1,4);o.pbrSGMap=t,s.pbrMapSize=n,s.specularMapIndex=i.indices.specularMap,s.glossinessMapIndex=i.indices.glossinessMap}if(t.emissiveMap.textures.length>0){const{relativeSizes:n,texture:a}=le(e,t.emissiveMap.textures,!0);o.emissiveMap=a,s.pbrMapSize||(s.pbrMapSize=n),s.emissiveMapIndex=t.emissiveMap.indices}const l={NUM_MATERIALS:n.length,NUM_DIFFUSE_MAPS:t.map.textures.length,NUM_NORMAL_MAPS:t.normalMap.textures.length,NUM_DIFFUSE_NORMAL_MAPS:Math.max(t.map.textures.length,t.normalMap.textures.length),NUM_PBR_MAPS:a.textures.length,NUM_PBR_SG_MAPS:i.textures.length,NUM_EMISSIVE_MAPS:t.emissiveMap.textures.length},{program:f}=_(e,{vertex:{source:"void main() {}"},fragment:{includes:["   \n    uniform Materials {\n    vec4 colorAndMaterialType[NUM_MATERIALS];\n    vec4 roughnessMetalnessNormalScale[NUM_MATERIALS];\n    vec4 alphaSpecularTintSheenSheenTint[NUM_MATERIALS];\n    vec4 clearcoaRoughnessSubfaceTransmission[NUM_MATERIALS];\n    vec4 iorAtDistanceAnisotropicWorkflow[NUM_MATERIALS];\n    vec4 extinction[NUM_MATERIALS];\n    vec4 specularColorGlossiness[NUM_MATERIALS];\n  \n    #if defined(NUM_DIFFUSE_MAPS) || defined(NUM_NORMAL_MAPS) || defined(NUM_PBR_MAPS)\n    ivec4 diffuseNormalRoughnessMetalnessMapIndex[NUM_MATERIALS];\n    #endif\n  \n    #if defined(NUM_EMISSIVE_MAPS) || defined(NUM_PBR_SG_MAPS)\n    ivec4 emissiveSpecularGlossinessMapIndex[NUM_MATERIALS];\n    #endif\n  \n    #if defined(NUM_DIFFUSE_MAPS) || defined(NUM_NORMAL_MAPS)\n    vec4 diffuseNormalMapSize[NUM_DIFFUSE_NORMAL_MAPS];\n    #endif\n  \n    #if defined(NUM_PBR_MAPS)\n    vec2 pbrMapSize[NUM_PBR_MAPS];\n    #else\n      #if defined(NUM_PBR_SG_MAPS)\n    vec2 pbrMapSize[NUM_PBR_SG_MAPS];\n      #else\n        #if defined(NUM_EMISSIVE_MAPS)\n    vec2 pbrMapSize[NUM_EMISSIVE_MAPS];\n        #endif\n      #endif\n    #endif\n  } materials;\n  \n  #ifdef NUM_DIFFUSE_MAPS\n  uniform mediump sampler2DArray diffuseMap;\n  #endif\n  \n  #ifdef NUM_NORMAL_MAPS\n  uniform mediump sampler2DArray normalMap;\n  #endif\n  \n  #ifdef NUM_PBR_MAPS\n  uniform mediump sampler2DArray pbrMap;\n  #endif\n  \n  #ifdef NUM_PBR_SG_MAPS\n  uniform mediump sampler2DArray pbrSGMap;\n  #endif\n  \n  #ifdef NUM_EMISSIVE_MAPS\n  uniform mediump sampler2DArray emissiveMap;\n  #endif\n  \n  float getMatType(int materialIndex) {\n    return materials.colorAndMaterialType[materialIndex].w;\n  }\n  \n  float getMatWorkflow(int materialIndex) {\n    return materials.iorAtDistanceAnisotropicWorkflow[materialIndex].w;\n  }\n  \n  vec3 getMatEmissive(int materialIndex, vec2 uv) {\n    // Todo: emissive Intensity\n    vec3 emissive = vec3(0.0);\n  \n    #ifdef NUM_EMISSIVE_MAPS\n    int emissiveMapIndex = materials.emissiveSpecularGlossinessMapIndex[materialIndex].x;\n    if(emissiveMapIndex >= 0) {\n      emissive = texture(emissiveMap, vec3(uv * materials.pbrMapSize[emissiveMapIndex].xy, emissiveMapIndex)).rgb;\n    }\n    #endif\n  \n    return emissive;\n  }\n  \n  vec3 getMatSpecularColor(int materialIndex, vec2 uv) {\n    vec3 specularColor = materials.specularColorGlossiness[materialIndex].rgb;\n  \n    #ifdef NUM_PBR_SG_MAPS\n    int specularMapIndex = materials.emissiveSpecularGlossinessMapIndex[materialIndex].y;\n    if(specularMapIndex >= 0) {\n      vec3 texelSpecular = texture(pbrSGMap, vec3(uv * materials.pbrMapSize[specularMapIndex].xy, specularMapIndex)).rgb;\n      texelSpecular = pow(texelSpecular, vec3(2.2));\n      specularColor *= texelSpecular;\n    }\n    #endif\n  \n    return specularColor;\n  }\n  \n  float getMatGlossiness(int materialIndex, vec2 uv) {\n    float glossiness = materials.specularColorGlossiness[materialIndex].a;\n    #ifdef NUM_PBR_SG_MAPS\n    int glossinessMapIndex = materials.emissiveSpecularGlossinessMapIndex[materialIndex].z;\n    if(glossinessMapIndex >= 0) {\n      float texelGlossiness = texture(pbrSGMap, vec3(uv * materials.pbrMapSize[glossinessMapIndex].xy, glossinessMapIndex)).a;\n      glossiness *= texelGlossiness;\n    }\n    #endif\n    return glossiness;\n  }\n  \n  float getMatRoughness(int materialIndex, vec2 uv) {\n    float workflow = getMatWorkflow(materialIndex);\n    float roughness = 0.0;\n    if(workflow > 0.1) {\n      roughness = 1.0 - getMatGlossiness(materialIndex, uv);\n    } else {\n      roughness = materials.roughnessMetalnessNormalScale[materialIndex].x;\n  \n      #ifdef NUM_PBR_MAPS\n      int roughnessMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialIndex].z;\n      if(roughnessMapIndex >= 0) {\n        roughness *= texture(pbrMap, vec3(uv * materials.pbrMapSize[roughnessMapIndex].xy, roughnessMapIndex)).g;\n      }\n      #endif\n    }\n    // Remap\n    return roughness * roughness;\n  }\n  \n  float max3(const vec3 v) {\n    return max(v.x, max(v.y, v.z));\n  }\n  \n  float computeMetallicFromSpecularColor(const vec3 specularColor) {\n    return max3(specularColor);\n  }\n  \n  vec3 computeDiffuseColor(const vec3 baseColor, float metallic) {\n    return baseColor * (1.0 - metallic);\n  }\n  \n  float getMatMetalness(int materialIndex, vec2 uv) {\n    float workflow = getMatWorkflow(materialIndex);\n    float metalness = 0.0;\n    if(workflow > 0.1) {\n      vec3 specularFactor = getMatSpecularColor(materialIndex, uv);\n      metalness = computeMetallicFromSpecularColor(specularFactor);\n    } else {\n      metalness = materials.roughnessMetalnessNormalScale[materialIndex].y;\n  \n      #ifdef NUM_PBR_MAPS\n      int metalnessMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialIndex].w;\n      if(metalnessMapIndex >= 0) {\n        metalness *= texture(pbrMap, vec3(uv * materials.pbrMapSize[metalnessMapIndex].xy, metalnessMapIndex)).b;\n      }\n      #endif\n    }\n  \n    return metalness;\n  }\n  \n  vec3 getMatColor(int materialIndex, vec2 uv) {\n    // if (enableAlbedo && bounce == 0) return vec3(1.);\n    vec3 color = materials.colorAndMaterialType[materialIndex].rgb;\n    #ifdef NUM_DIFFUSE_MAPS\n    int diffuseMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialIndex].x;\n    if(diffuseMapIndex >= 0) {\n      color *= texture(diffuseMap, vec3(uv * materials.diffuseNormalMapSize[diffuseMapIndex].xy, diffuseMapIndex)).rgb;\n    }\n    #endif\n  \n    float workflow = getMatWorkflow(materialIndex);\n    if(workflow > 0.1) {\n      vec3 specularFactor = getMatSpecularColor(materialIndex, uv);\n      color = computeDiffuseColor(color, computeMetallicFromSpecularColor(specularFactor));\n    }\n  \n    return color;\n  }\n  \n  vec3 getMatNormal(int materialIndex, vec2 uv, vec3 normal, vec3 dp1, vec3 dp2, vec2 duv1, vec2 duv2, inout vec3 tangent, inout vec3 bitangent) {\n    // http://www.thetenthplanet.de/archives/1180\n    // Compute co-tangent and co-bitangent vectors\n    vec3 dp2perp = cross(dp2, normal);\n    vec3 dp1perp = cross(normal, dp1);\n    vec3 dpdu = dp2perp * duv1.x + dp1perp * duv2.x;\n    vec3 dpdv = dp2perp * duv1.y + dp1perp * duv2.y;\n    float invmax = inversesqrt(max(dot(dpdu, dpdu), dot(dpdv, dpdv)));\n    dpdu *= invmax;\n    dpdv *= invmax;\n  \n    // All world space\n    // Todo: /3ed-2018/Materials/BSDFs => WorldToLocal/LocalToWorld\n    tangent = normalize(dpdu);\n    bitangent = normalize(dpdv);\n  \n  #ifdef NUM_NORMAL_MAPS\n    int normalMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialIndex].y;\n    if(normalMapIndex >= 0) {\n      vec3 n = 2.0 * texture(normalMap, vec3(uv * materials.diffuseNormalMapSize[normalMapIndex].zw, normalMapIndex)).rgb - 1.0;\n      n.xy *= materials.roughnessMetalnessNormalScale[materialIndex].zw;\n  \n      mat3 tbn = mat3(dpdu, dpdv, normal);\n  \n      return normalize(tbn * n);\n    } else {\n      return normal;\n    }\n  #endif\n  \n    return normal;\n  }\n  \n  // alphaSpecularTintSheenSheenTint\n  float getMatAlpha(int materialIndex, vec2 uv) {\n    float alpha = materials.alphaSpecularTintSheenSheenTint[materialIndex].x;\n    #ifdef NUM_DIFFUSE_MAPS\n    int diffuseMapIndex = materials.diffuseNormalRoughnessMetalnessMapIndex[materialIndex].x;\n    if(diffuseMapIndex >= 0) {\n      alpha *= texture(diffuseMap, vec3(uv * materials.diffuseNormalMapSize[diffuseMapIndex].xy, diffuseMapIndex)).a;\n    }\n    #endif\n    return alpha;\n  }\n  \n  float getMatSpecularTint(int materialIndex) {\n    return materials.alphaSpecularTintSheenSheenTint[materialIndex].y;\n  }\n  \n  float getMatSheen(int materialIndex) {\n    return materials.alphaSpecularTintSheenSheenTint[materialIndex].z;\n  }\n  \n  float getMatSheenTint(int materialIndex) {\n    return materials.alphaSpecularTintSheenSheenTint[materialIndex].w;\n  }\n  \n  // clearcoaRoughnessSubfaceTransmission\n  float getMatClearcoat(int materialIndex) {\n    return materials.clearcoaRoughnessSubfaceTransmission[materialIndex].x;\n  }\n  \n  float getMatClearcoatRoughness(int materialIndex) {\n    return materials.clearcoaRoughnessSubfaceTransmission[materialIndex].y;\n  }\n  \n  float getMatSubface(int materialIndex) {\n    return materials.clearcoaRoughnessSubfaceTransmission[materialIndex].z;\n  }\n  \n  float getMatTransmission(int materialIndex) {\n    return materials.clearcoaRoughnessSubfaceTransmission[materialIndex].w;\n  }\n  \n  // iorAtDistanceAnisotropicWorkflow\n  float getMatIOR(int materialIndex) {\n    return materials.iorAtDistanceAnisotropicWorkflow[materialIndex].x;\n  }\n  \n  float getMatAtDistance(int materialIndex) {\n    return materials.iorAtDistanceAnisotropicWorkflow[materialIndex].y;\n  }\n  \n  float getMatAnisotropic(int materialIndex) {\n    return materials.iorAtDistanceAnisotropicWorkflow[materialIndex].z;\n  }\n  \n  vec3 getMatExtinction(int materialIndex) {\n    return materials.extinction[materialIndex].rgb;\n  }\n"],source:"void main() {}"},defines:l});return function(e,n,t){const a=function(e,n,t){const a=e.getUniformBlockIndex(n,t),i=e.getActiveUniformBlockParameter(n,a,e.UNIFORM_BLOCK_DATA_SIZE),o=function(e,n,t){const a=e.getActiveUniformBlockParameter(n,t,e.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),i=e.getActiveUniforms(n,a,e.UNIFORM_OFFSET),o=e.getActiveUniforms(n,a,e.UNIFORM_ARRAY_STRIDE),r={};for(let t=0;t<a.length;t++){const{name:s,type:l,size:f}=e.getActiveUniform(n,a[t]);r[s]={type:l,size:f,offset:i[t],stride:o[t]}}return r}(e,n,a),r=e.createBuffer();e.bindBuffer(e.UNIFORM_BUFFER,r),e.bufferData(e.UNIFORM_BUFFER,i,e.STATIC_DRAW);const s=new DataView(new ArrayBuffer(i));return{set:function(n,t){if(!o[n])return;const{type:a,size:i,offset:r,stride:l}=o[n];switch(a){case e.FLOAT:ie(s,"setFloat32",i,r,l,1,t);break;case e.FLOAT_VEC2:ie(s,"setFloat32",i,r,l,2,t);break;case e.FLOAT_VEC3:ie(s,"setFloat32",i,r,l,3,t);break;case e.FLOAT_VEC4:ie(s,"setFloat32",i,r,l,4,t);break;case e.INT:ie(s,"setInt32",i,r,l,1,t);break;case e.INT_VEC2:ie(s,"setInt32",i,r,l,2,t);break;case e.INT_VEC3:ie(s,"setInt32",i,r,l,3,t);break;case e.INT_VEC4:ie(s,"setInt32",i,r,l,4,t);break;case e.BOOL:ie(s,"setUint32",i,r,l,1,t);break;default:console.warn("UniformBuffer: Unsupported type")}},bind:function(n){e.bindBuffer(e.UNIFORM_BUFFER,r),e.bufferSubData(e.UNIFORM_BUFFER,0,s),e.bindBufferBase(e.UNIFORM_BUFFER,n,r)}}}(e,n,"Materials");a.set("Materials.colorAndMaterialType[0]",r({data:[].concat(...t.color.map((e=>e.toArray()))),channels:3},{data:t.type,channels:1})),a.set("Materials.roughnessMetalnessNormalScale[0]",r({data:t.roughness,channels:1},{data:t.metalness,channels:1},{data:[].concat(...t.normalScale.map((e=>e.toArray()))),channels:2})),a.set("Materials.alphaSpecularTintSheenSheenTint[0]",r({data:t.alpha,channels:1},{data:t.specularTint,channels:1},{data:t.sheen,channels:1},{data:t.sheenTint,channels:1})),a.set("Materials.clearcoaRoughnessSubfaceTransmission[0]",r({data:t.clearcoat,channels:1},{data:t.clearcoatRoughness,channels:1},{data:t.subsurface,channels:1},{data:t.transmission,channels:1})),a.set("Materials.iorAtDistanceAnisotropicWorkflow[0]",r({data:t.ior,channels:1},{data:t.atDistance,channels:1},{data:t.anisotropic,channels:1},{data:t.workflow,channels:1})),a.set("Materials.specularColorGlossiness[0]",r({data:[].concat(...t.specularColor.map((e=>e.toArray()))),channels:3},{data:t.glossiness,channels:1})),a.set("Materials.extinction[0]",r({data:[].concat(...t.extinction.map((e=>e.toArray()))),channels:3},{data:t.anisotropic,channels:1})),a.set("Materials.diffuseNormalRoughnessMetalnessMapIndex[0]",r({data:t.diffuseMapIndex,channels:1},{data:t.normalMapIndex,channels:1},{data:t.roughnessMapIndex,channels:1},{data:t.metalnessMapIndex,channels:1})),a.set("Materials.emissiveSpecularGlossinessMapIndex[0]",r({data:t.emissiveMapIndex,channels:1},{data:t.specularMapIndex,channels:1},{data:t.glossinessMapIndex,channels:1},{data:t.emissiveMapIndex,channels:1})),a.set("Materials.diffuseNormalMapSize[0]",r({data:t.diffuseMapSize,channels:2},{data:t.normalMapSize,channels:2})),a.set("Materials.pbrMapSize[0]",t.pbrMapSize),a.bind(0)}(e,f,s),{defines:l,textures:o}}function le(e,n,t=!1,a=3){const i=n.map((e=>e.image)),o=n.map((e=>e.flipY)),{maxSize:r,relativeSizes:s}=function(e){const n={width:0,height:0};for(const t of e)n.width=Math.max(n.width,t.width),n.height=Math.max(n.height,t.height);const t=[];for(const a of e)t.push(a.width/n.width),t.push(a.height/n.height);return{maxSize:n,relativeSizes:t}}(i);return{texture:c(e,{width:r.width,height:r.height,gammaCorrection:t,data:i,flipY:o,channels:a,minFilter:e.LINEAR,magFilter:e.LINEAR}),relativeSizes:s}}async function fe({gl:e,optionalExtensions:t,scene:i,camera:r,toneMapping:l,bounces:f,envMapIntensity:u,enviromentVisible:m,movingDownsampling:L,enableDenoise:x,enableTemporalDenoise:h,enableSpatialDenoise:v,useWorker:A,loadingCallback:S}){const F=p(e),M=function(e){let t,a,i,o;const r=new n.Vector2(1,1);let s=function(e){const n=e.getParameter(e.MAX_RENDERBUFFER_SIZE);return n<=8192?8e4:16384===n?15e4:n>=32768?4e5:void 0}(e);function l(){const e=t/a;i=Math.round(d(Math.sqrt(s*e),1,t)),o=Math.round(d(i/e,1,a)),r.set(i/t,o/a)}return{adjustSize:function(e){e&&(s+=600*(20-e),s=d(s,8192,t*a),l())},setSize:function(e,n){t=e,a=n,l()},scale:r,get width(){return i},get height(){return o}}}(e),N=o(i,r),P=s(N.meshes),y=se(e,P.materials),R=function(e){const n=e.createVertexArray();return e.bindVertexArray(n),e.bindBuffer(e.ARRAY_BUFFER,e.createBuffer()),e.bufferData(e.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]),e.STATIC_DRAW),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,0,0),e.bindVertexArray(null),{draw:function(){e.bindVertexArray(n),e.drawArrays(e.TRIANGLES,0,6)},vertexShader:g(e,{vertex:T})}}(e),E=ne(e,{materialBuffer:y,mergedMesh:P}),U=function(e,n){const{fullscreenQuad:t,toneMapping:i}=n;let o;const r={gl:e,vertex:t.vertexShader,fragment:J},s=_(e,r);s.setUniform("toneMappingFun",j[i]);const l=new a.Vector2(1,1);return{draw:function(n,a){let{light:i,lightScale:r}=n;if(r=r||l,s.setTexture("lightTex",i),s.setUniform("lightScale",r.x,r.y),a)return o.bind(),e.clear(e.COLOR_BUFFER_BIT),e.viewport(0,0,e.drawingBufferWidth,e.drawingBufferHeight),s.useProgram(),t.draw(),o.unbind(),o;s.useProgram(),t.draw()},setToneMapping:function(e){s.setUniform("toneMappingFun",j[e])},setSize:function(n,t){o=G(e,{color:{0:c(e,{width:n,height:t,storage:"byte",magFilter:e.LINEAR,minFilter:e.LINEAR})}})}}}(e,{fullscreenQuad:R,toneMapping:l}),X=function(e,n){const{fullscreenQuad:t}=n,a=_(e,{gl:e,vertex:t.vertexShader,fragment:I});return{draw:function(e){let{light:n}=e;a.setTexture("inputBuffer",n),a.useProgram(),t.draw()},setSize:function(e,n){a.setUniform("resolution",1/e,1/n)}}}(e,{fullscreenQuad:R}),B=function(e,t){const{fullscreenQuad:a,maxReprojectedSamples:i}=t;let o=.2,r=.2;const s=_(e,{defines:{MAX_SAMPLES:i.toFixed(1)},vertex:a.vertexShader,fragment:q}),l=new n.Matrix4;return{draw:function(e){const{light:n,position:t,color:i,previousColor:l,previousLight:f,previousPosition:d,previousMomentLengthVariance:c}=e;s.setTexture("lightTex",n),s.setTexture("positionTex",t),s.setTexture("colorTex",i),s.setTexture("previousLightTex",f),s.setTexture("previousPositionTex",d),s.setTexture("previousColorTex",l),s.setTexture("previousMomentLengthVarianceTex",c),s.setUniform("colorBlendFactor",o),s.setUniform("momentBlendFactor",r),s.useProgram(),a.draw()},setJitter:function(e,n){s.setUniform("jitter",e,n)},setPreviousCamera:function(e){l.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),s.setUniform("historyCamera",l.elements)},setDenoiseColorBlendFactor:function(e){o=e},setDenoiseMomentBlendFactor:function(e){r=e},setDemodulateAlbedo:function(e){s.setUniform("demodulateAlbedo",e)},getDenoiseFactors:function(){return{colorBlendFactor:o,momentBlendFactor:r}}}}(e,{fullscreenQuad:R,maxReprojectedSamples:20}),V=b(e,{fullscreenQuad:R,toneMapping:l}),z=await O(e,{bounces:f,decomposedScene:N,fullscreenQuad:R,materialBuffer:y,mergedMesh:P,optionalExtensions:t,scene:i,envMapIntensity:u,enviromentVisible:m,useWorker:A,loadingCallback:S}),C=new n.PerspectiveCamera,w=new Image;let Q,D;w.src="data:image/png;base64,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",w.onload=()=>{z.setNoise(w),$=!0};let Y,W,H,k,Z,K,$=!1,ee=0,te=!0,ie=0,oe=0,re=()=>{};function le(){let e=k;k=Z,Z=e}function fe(){let e=Y;Y=W,W=e}function de(e=!0){const n=Number(e&&h&&v);B.setDemodulateAlbedo(n),V.setDemodulateAlbedo(n)}function ce(e,n){z.setCamera(e),E.setCamera(e),B.setPreviousCamera(n),n.copy(e)}function ue(e,n,t=!0){z.setSize(e,n),z.setFrameCount(ee);const a=t?(Math.random()-.5)/e:0,i=t?(Math.random()-.5)/n:0;x||z.setJitter(a,i),0===ee?z.setStrataCount(1):4===ee?z.setStrataCount(6):z.nextSeed()}function pe(e,n){return function(e,n,t=1e-4){for(let a=0;a<e.length;a++)if(Math.abs(e[a]-n[a])>t)return!1;return!0}(e.matrixWorld.elements,n.matrixWorld.elements)&&e.aspect===n.aspect&&e.fov===n.fov}function me(n){n.bind(),e.clear(e.COLOR_BUFFER_BIT),n.unbind()}function Le(n,t,a){n.bind(),e.blendEquation(e.FUNC_ADD),e.blendFunc(e.ONE,e.ONE),e.enable(e.BLEND),e.viewport(0,0,t,a),z.draw(),e.disable(e.BLEND),n.unbind()}function xe(n,t){e.viewport(0,0,e.drawingBufferWidth,e.drawingBufferHeight),U.draw({light:n,lightScale:t}),K=n}function he(e){let n=U.draw({light:e},!0);X.draw({light:n.color[0]})}function ve(){Y.bind(),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT),e.viewport(0,0,ie,oe),E.draw(),Y.unbind(),V.setGBuffers({position:Y.color[0],normal:Y.color[1],color:Y.color[2]})}function Ae(){h&&(k.bind(),e.viewport(0,0,ie,oe),B.draw({light:H.color[0],position:Y.color[0],color:Y.color[2],previousLight:K,previousPosition:W.color[0],previousColor:W.color[2],previousMomentLengthVariance:Z.color[1]}),k.unbind(),v||(he(k.color[0]),K=k.color[0])),v&&(h?(he(V.draw({light:k.color[0],reprojectData:Z.color[1]}).color[0]),K=k.color[0]):(he(V.draw({light:H.color[0],reprojectData:null}).color[0]),K=H.color[0]))}function _e(n=!1){const{x:t,y:a,tileWidth:i,tileHeight:o,isFirstTile:r,isLastTile:s}=F.nextTile(D);r&&(0===ee&&(me(H),B.setPreviousCamera(C)),ue(ie,oe,!0),ve(),z.bindTextures()),function(n,t,a,i,o){e.scissor(t,a,i,o),e.enable(e.SCISSOR_TEST),Le(n,ie,oe),e.disable(e.SCISSOR_TEST)}(H,t,a,i,o),n&&!s&&xe(H.color[0]),s&&(x&&(h||v)?(K=H.color[0],Ae(),K=H.color[0]):xe(H.color[0]),le(),fe(),ee++,re())}function ge(){let n,t,a;ue(M.width,M.height,!1),z.bindTextures(),n=H,t=M.width,a=M.height,n.bind(),e.viewport(0,0,t,a),z.draw(),n.unbind(),xe(H.color[0],M.scale),me(H)}de(!1);return{draw:function(e){$&&(pe(e,C)?_e():(ce(e,C),te?te=!1:L?ge():_e(!0),ee=0,F.reset()))},fullDraw:function(e){if($){if(fe(),le(),pe(e,C))ee++;else{if(L)return ce(e,C),ee=0,ge();ee=0,me(H)}ce(e,C),ue(ie,oe,!0),ve(),z.bindTextures(),Le(H,ie,oe),x&&(h||v)?Ae():xe(H.color[0]),re()}},setSize:function(n,t){ie=n,oe=t,F.setSize(n,t),M.setSize(n,t),function(n,t){H=ae(e,{color:{0:c(e,{width:n,height:t,storage:"float",magFilter:e.LINEAR,minFilter:e.LINEAR})}}),K=H.color[0];const a=()=>ae(e,{color:{0:c(e,{width:n,height:t,storage:"float",magFilter:e.LINEAR,minFilter:e.LINEAR}),1:c(e,{width:n,height:t,storage:"float",channels:4,magFilter:e.LINEAR,minFilter:e.LINEAR})}});k=a(),Z=a();const i=c(e,{width:n,height:t,storage:"halfFloat"}),o=c(e,{width:n,height:t,storage:"float"}),r=function(e,n,t){const a=e.createRenderbuffer(),i=e.RENDERBUFFER;return e.bindRenderbuffer(i,a),e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_COMPONENT24,n,t),e.bindRenderbuffer(i,null),{target:i,texture:a}}(e,n,t),s=()=>ae(e,{color:{0:c(e,{width:n,height:t,storage:"float"}),1:i,2:o},depth:r});Y=s(),W=s()}(n,t),V.setSize(n,t),U.setSize(n,t),X.setSize(n,t),te=!0},time:function(e){D=e-Q,Q=e},reset:function(){ee=0,F.reset(),me(H),me(k),me(Z)},getTotalSamplesRendered:()=>ee,setfullSampleCallbackCallBack:function(e){re=e},updateBounces:function(e){z.updateBounces(e)},updateEnvLight:function(){const e=o(i,r);z.updateEnvLight(e)},updateMeshLight:function(){const e=o(i,r);z.updateMeshLight(e)},setEnvMapIntensity:function(e){z.setEnvMapIntensity(e)},setEnviromentVisible:function(e){z.setEnviromentVisible(e)},setToneMapping:function(e){U.setToneMapping(e)},setMovingDownsampling:function(e){L=e},setDenoiseStatus:function(e){x=e},setTemporalDenoiseStatus:function(e){h=e,de()},setDenoiseColorBlendFactor:function(e){B.setDenoiseColorBlendFactor(e)},setDenoiseMomentBlendFactor:function(e){B.setDenoiseMomentBlendFactor(e)},setSpatialDenoiseStatus:function(e){v=e,de()},setDenoiseColorFactor:function(e){V.setColorFactor(e)},setDenoiseNormalFactor:function(e){V.setNormalFactor(e)},setDenoisePositionFactor:function(e){V.setPositionFactor(e)},getDenoiseFactors:function(){return Object.assign(V.getDenoiseFactors(),B.getDenoiseFactors())},setDemodulateAlbedo:de}}const de=["EXT_color_buffer_float","EXT_float_blend"],ce=["OES_texture_float_linear"];class ue{constructor(e={}){this.canvas=e.canvas||document.createElement("canvas"),this.gl=this.canvas.getContext("webgl2",{alpha:e.canvasAlpha||!1,depth:!0,stencil:!1,antialias:!1,powerPreference:"high-performance",failIfMajorPerformanceCaveat:!0}),m(this.gl,de),this.optionalExtensions=m(this.gl,ce),this._bounces=2,this._envMapIntensity=1,this._toneMapping=a.LinearToneMapping,this._movingDownsampling=!1,this._enableDenoise=!1,this._enableTemporalDenoise=!0,this._enableSpatialDenoise=!0,this._fullSampleCallback=null,this._enviromentVisible=!0,this.useTileRender=!1,this.renderWhenOffFocus=!0,this.useWorker=e.useWorker||!0,this.loadingCallback=e.loadingCallback||{onProgress:e=>console.log(e),onComplete:e=>console.log(e)},this._isBuilding=!0,this.needsUpdate=!1,this.size=new a.Vector2(this.canvas.width,this.canvas.height),this.pixelRatio=1,this.pipeline=null,this.currentTime=NaN,this.isValidTime=1,this.lastFocus=!1,this.domElement=this.canvas}static isSupported(){const e=document.createElement("canvas").getContext("webgl2",{failIfMajorPerformanceCaveat:!0});if(!e)return!1;const n=m(e,de);for(let e in n)if(!n[e])return!1;return!0}async buildScene(e,n){const{gl:t,optionalExtensions:a,bounces:i,size:o,toneMapping:r,envMapIntensity:s,enviromentVisible:l,movingDownsampling:f,enableDenoise:d,enableTemporalDenoise:c,enableSpatialDenoise:u,useWorker:p,loadingCallback:m}=this;this._isBuilding=!0,e.updateMatrixWorld(),this.pipeline=await fe({gl:t,optionalExtensions:a,scene:e,camera:n,toneMapping:r,bounces:i,envMapIntensity:s,enviromentVisible:l,movingDownsampling:f,enableDenoise:d,enableTemporalDenoise:c,enableSpatialDenoise:u,useWorker:p,loadingCallback:m}),this.setSize(o.width,o.height),this._isBuilding=!1,"function"==typeof(null==m?void 0:m.onComplete)&&m.onComplete("Complete!")}set bounces(e){var n;this._bounces=e,null==(n=this.pipeline)||n.updateBounces(e)}get bounces(){return this._bounces}set envMapIntensity(e){var n;e=Number(e),this._envMapIntensity=e,null==(n=this.pipeline)||n.setEnvMapIntensity(e)}get envMapIntensity(){return this._envMapIntensity}set toneMapping(e){var n;this._toneMapping=e,null==(n=this.pipeline)||n.setToneMapping(e)}get toneMapping(){return this._toneMapping}set enviromentVisible(e){var n;this._enviromentVisible=e,null==(n=this.pipeline)||n.setEnviromentVisible(e)}get enviromentVisible(){return this._enviromentVisible}set movingDownsampling(e){var n;e=!!e,this._movingDownsampling=e,null==(n=this.pipeline)||n.setMovingDownsampling(e)}get movingDownsampling(){return this._movingDownsampling}set enableDenoise(e){var n;e=!!e,this._enableDenoise=e,null==(n=this.pipeline)||n.setDenoiseStatus(e)}get enableDenoise(){return this._enableDenoise}set enableTemporalDenoise(e){var n;e=!!e,this._enableTemporalDenoise=e,null==(n=this.pipeline)||n.setTemporalDenoiseStatus(e)}get enableTemporalDenoise(){return this._enableTemporalDenoise}set enableSpatialDenoise(e){var n;e=!!e,this._enableSpatialDenoise=e,null==(n=this.pipeline)||n.setSpatialDenoiseStatus(e)}get enableSpatialDenoise(){return this._enableSpatialDenoise}set fullSampleCallback(e){var n;"function"==typeof e&&(this._fullSampleCallback=e,null==(n=this.pipeline)||n.setfullSampleCallbackCallBack(e))}get fullSampleCallback(){return this._fullSampleCallback}updateEnvLight(){var e;null==(e=this.pipeline)||e.updateEnvLight()}updateMeshLight(){var e;null==(e=this.pipeline)||e.updateMeshLight()}setDenoiseColorBlendFactor(e){var n;null==(n=this.pipeline)||n.setDenoiseColorBlendFactor(e)}setDenoiseMomentBlendFactor(e){var n;null==(n=this.pipeline)||n.setDenoiseMomentBlendFactor(e)}setDenoiseColorFactor(e){var n;null==(n=this.pipeline)||n.setDenoiseColorFactor(e)}setDenoiseNormalFactor(e){var n;null==(n=this.pipeline)||n.setDenoiseNormalFactor(e)}setDenoisePositionFactor(e){var n;null==(n=this.pipeline)||n.setDenoisePositionFactor(e)}setDemodulateAlbedo(e){var n;null==(n=this.pipeline)||n.setDemodulateAlbedo(e),this.needsUpdate=!0}getDenoiseFactors(){var e;return null==(e=this.pipeline)?void 0:e.getDenoiseFactors()}setSize(e,n,t=!0){const{size:a,canvas:i,pipeline:o,pixelRatio:r}=this;a.set(e,n),i.width=a.width*r,i.height=a.height*r,t&&(i.style.width=`${a.width}px`,i.style.height=`${a.height}px`),this.pipeline&&o.setSize(a.width*r,a.height*r)}getSize(e){const{size:n}=this;return e||(e=new a.Vector2),e.copy(n)}setPixelRatio(e){const{size:n}=this;e&&(this.pixelRatio=e,this.setSize(n.width,n.height,!1))}getPixelRatio(){return this.pixelRatio}getTotalSamples(){var e;return null==(e=this.pipeline)?void 0:e.getTotalSamplesRendered()}restartTimer(){this.isValidTime=NaN}render(e,n){if(!this._isBuilding)if(this.pipeline){if(!this.renderWhenOffFocus){const e=document.hasFocus();if(!e)return this.lastFocus=e,this.lastFocus;e&&!this.lastFocus&&(this.lastFocus=e,this.restartTimer())}this.needsUpdate&&(this.needsUpdate=!1,this.pipeline.reset()),this.currentTime=performance.now(),this.pipeline.time(this.isValidTime*this.currentTime),this.isValidTime=1,this.currentTime=NaN,n.updateMatrixWorld(),this.useTileRender?this.pipeline.draw(n):this.pipeline.fullDraw(n)}else console.error("The scene needs to be built first!")}dispose(){this.pipeline=null,this.domElement.remove()}}class pe extends n.Light{constructor(e,t){super(e,t),this.type="DirectionalLight",this.target=new n.Vector3}}class me extends n.Light{constructor(e,t,a=10,i=10){super(e,t),this.type="RectAreaLight",this.width=a,this.height=i,this.target=new n.Vector3}copy(e){super.copy(e),this.width=e.width,this.height=e.height}}class Le extends n.Light{constructor(e,n,t=1){super(e,n),this.type="SphereAreaLight",this.radius=t}}class xe extends n.Light{constructor(e,n){super(e,n),this.type="PointLight"}}class he extends n.Light{constructor(e,n,t,a){super(e,n),this.type="QuadLight",this.v1=t,this.v2=a}}window.THREE&&(THREE.QuadLight=he,THREE.PointLight=xe,THREE.SphereAreaLight=Le,THREE.RectAreaLight=me,THREE.DirectionalLight=pe,THREE.RayTracingMaterial=i,THREE.RayTracingRenderer=ue),e.DirectionalLight=pe,e.PointLight=xe,e.QuadLight=he,e.RayTracingMaterial=i,e.RayTracingRenderer=ue,e.RectAreaLight=me,e.SphereAreaLight=Le,Object.defineProperty(e,"__esModule",{value:!0})}));
